<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>[Troubleshooting - DB] 인덱스(Index)와 데드락(DeadLock) | this.hocaron</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="[Troubleshooting - DB] 인덱스(Index)와 데드락(DeadLock)" />
<meta name="author" content="Hocaron" />
<meta property="og:locale" content="ko" />
<meta name="description" content="역시 해치웠나를 외치면 안 되는 것인가… 또 울기 시작한 페페… (그만 울어잇!) 의미있는 경험으로 남기기위해 기록해보자. 데드락이 발생하는 상황 다시 재현 현재 테이블 상태 CREATE TABLE parent ( id bigint not null primary key, name varchar(255) null, updated_at datetime(6) null ); CREATE TABLE child ( id bigint not null primary key, name varchar(255) null, parent_id bigint null, CONSTRAINT parent_id_unique UNIQUE (parent_id) ); CREATE TABLE child_index ( id bigint not null primary key, name varchar(255) null, parent_id bigint null, ); CREATE INDEX parent_id ON child_index (parent_id); INSERT INTO parent VALUES (1, &#39;parent_1&#39;, NOW()); parent 테이블의 id를 index로 가지고 있는 child_index 테이블 생성(외래키는 운영에서 삭제되어서 테스트시 고려하지 않습니다) parent 테이블의 id를 유니크 키로 가지고 있는 child 테이블 생성(마찬가지로 외래키 고려하지 않습니다.) parent 테이블에 테스트 데이터 적재 그럼 이제 데드락을 발생시켜 보자 index 걸려있는 row delete → index 걸려있는 자식 row insert가 두개의 세션에서 수행되면, 데드락이 발생 💣 TX1 TX2 lock BEGIN ; DELETE FROM child_index WHERE parent_id = 2;   (1) child X Lock 인데, TX2에서 X Lock 획득 가능할까 🤔   BEGIN ; DELETE FROM child_index WHERE parent_id = 2; (2) child X Lock INSERT INTO child_index VALUES (‘1’, ‘name2’, 2);   (3) child X,INSERT_INTENTION Lock 대기   INSERT INTO child_index VALUES (‘2’, ‘name2’, 2); (4) child X,INSERT_INTENTION Lock 대기   Deadlock found when trying to get lock; try restarting transaction (4) child X lock 이 필요하지만, (2) 에서 child X lock 상태 (4) 해소를 위해서 (3) 해소 필요 -&gt; (3) 해소 위해서 TX2 커밋 필요 -&gt; TX2 커밋하려면 (4) 해소 필요 -&gt; 데드락 발생 운영환경에서 데드락이 발생하는 로직을 살펴보자 index 걸려있는 row delete → index 걸려있는 자식 row insert가 두개의 세션에서 수행되면, 데드락이 발생 💣 SELECT * from parent WHERE id = 1; INSERT INTO child VALUES (1, &#39;child_1&#39;, 1); DELETE FROM child_index WHERE parent_id = 1; INSERT INTO child_index VALUES (1, &#39;child_index_1&#39;, 1); UPDATE parent SET updated_at = NOW() WHERE id = 1; @Transactional public void createChildAndChildIndex (long parentId) { var parent = parentRepository.findById(parentId); childIndexRepository.deleteByParent(parent); childIndexRepository.save(new Child_Index(&#39;child_index_1&#39;, parent)); } 한가지 신기한 점은 delete 하려는 데이터가 없을 때, 데드락이 발생한다. delete 하려는 데이터가 있는 경우에는 같은 로직을 수행하면 락을 잡을 때까지 기다리게 된다. 원인은 알았고, 서버에서 데드락을 해결할 수 있는 방법을 고민해보자 ❎ 첫번째 시도, 존재하는 경우에만 row 삭제 @Transactional public void createParent (long parentId) { var parent = parentRepository.findById(parentId); if(childIndexRepository.findByParent(parent).isPresent()) { childIndexRepository.deleteByParent(parent); } childIndexRepository.save(new Child_Index(&#39;child_index_1&#39;, parent)); } 무조건 delete 하는 로직으로 인한 배타락은 방지 가능하다. 동시 요청시에 childIndexRepository.findByParent 에 데이터가 없는 경우로 분기처리되는 경우, 데이터가 2배로 적재될 수 있다. 300ms 로 쓰레드 sleep() 걸어서 테스트 결과 2배로 쌓이는 것을 확인 ✅ 두번째 시도, 존재하는 경우에만 row 삭제하면서 유니크 조건 추가 CREATE TABLE child_index ( id bigint not null primary key, name varchar(255) null, parent_id bigint null, CONSTRAINT parent_id_unique UNIQUE (parent_id) ); CREATE INDEX parent_id ON child_index (parent_id); 동시 요청시에 childIndexRepository.findByParent 에 데이터가 없는 경우로 분기처리되는 경우, 후에 커밋되어 적재된 데이터는 중복키 에러 처리된다. ❎ 세번째 시도, Redis 에 동시성 제어를 위한 키 추가 간헐적인 데드락이고, 위 서비스에서 Redis를 사용하지 않아 캐시 리소스가 더 클 것 같아 나가리! ❎ 네번째 시도, 요청 제한 Bucket4j를 이용해서 클라이언트가 특정 시간 프레임 내에 만들 수 있는 API 호출 수를 제한한다. 위 서비스는 서버가 여러대인 경우라서 다른 서버로 동시 요청이 들어가는 경우, 데드락 방지 불가능 정리 데이터가 없는 경우, 삭제 쿼리를 날리면 delete, select 는 가능하지만 insert 시에 락을 기다리게 된다. 락이 궁금하다면, MySQL 공식문서 중 InnoDB Lock 메뉴얼을 참고해보자. (예제와 함께 정리가 너무 잘 되어있는 것을 볼 수 있다.) 흥미로운 실험 인덱스가 걸린 컬럼 기준으로 쿼리 데이터가 있는 경우에는, 2번째 트랜잭션에서 delete 시에 락 획득을 기다린다. BEGIN ; DELETE FROM child_index WHERE parent_id = 1; INSERT INTO child_index VALUES (1, &#39;child_index_1&#39;, 1); COMMIT ; 데이터가 없는 경우에는, 2번째 트랜잭션에서 delete 시에 락 획득이 바로 가능하다. BEGIN ; DELETE FROM child_index WHERE parent_id = 1; INSERT INTO child_index VALUES (1, &#39;child_index_1&#39;, 1); COMMIT ; 인덱스가 걸리지 않은 컬럼 기준으로 쿼리 데이터가 있는 / 없는 경우, 2번째 트랜잭션에서 delete 시에 락 획득을 기다린다. BEGIN ; DELETE FROM child_index WHERE name = &#39;child_index_2&#39;; INSERT INTO child_index VALUES (1, &#39;child_index_1&#39;, 1); COMMIT ; 기록용 SHOW ENGINE innodb STATUS; *** (1) TRANSACTION:TRANSACTION 13034, ACTIVE 6 sec insertingmysql tables in use 1, locked 1LOCK WAIT 4 lock struct(s), heap size 1128, 3 row lock(s), undo log entries 1MySQL thread id 280, OS thread handle 6136639488, query id 21716 localhost 127.0.0.1 root update/* ApplicationName=DataGrip 2022.3.2 */ insert into child values (&#39;2&#39;, &#39;name2&#39;, 2) *** (1) HOLDS THE LOCK(S):RECORD LOCKS space id 154 page no 4 n bits 72 index PRIMARY of table jpa.child trx id 13034 lock_mode X locks rec but not gapRecord lock, heap no 3 PHYSICAL RECORD: n_fields 5; compact format; info bits 0 *** (1) WAITING FOR THIS LOCK TO BE GRANTED:RECORD LOCKS space id 154 page no 5 n bits 72 index parent_id of table jpa.child trx id 13034 lock_mode X insert intention waitingRecord lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0 *** (2) TRANSACTION:TRANSACTION 13035, ACTIVE 4 sec insertingmysql tables in use 1, locked 1LOCK WAIT 3 lock struct(s), heap size 1128, 2 row lock(s)MySQL thread id 281, OS thread handle 6135525376, query id 21726 localhost 127.0.0.1 root update/* ApplicationName=DataGrip 2022.3.2 */ insert into child values (&#39;2&#39;, &#39;name2&#39;, 2) *** (2) HOLDS THE LOCK(S):RECORD LOCKS space id 154 page no 5 n bits 72 index parent_id of table jpa.child trx id 13035 lock_mode XRecord lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0 *** (2) WAITING FOR THIS LOCK TO BE GRANTED:RECORD LOCKS space id 154 page no 4 n bits 72 index PRIMARY of table jpa.child trx id 13035 lock mode S locks rec but not gap waitingRecord lock, heap no 3 PHYSICAL RECORD: n_fields 5; compact format; info bits 0 - SELECT * FROM performance_schema.data_locks; | INDEX\_NAME | OBJECT\_INSTANCE\_BEGIN | LOCK\_TYPE | LOCK\_MODE | LOCK\_STATUS | LOCK\_DATA | | :--- | :--- | :--- | :--- | :--- | :--- | | null | 4813003272 | TABLE | IX | GRANTED | null | | parent\_id | 4823656472 | RECORD | X | GRANTED | supremum pseudo-record | | parent\_id | 4823656816 | RECORD | X,INSERT\_INTENTION | GRANTED | supremum pseudo-record | | parent\_id | 4823657160 | RECORD | X,GAP | GRANTED | 1, 1 |" />
<meta property="og:description" content="역시 해치웠나를 외치면 안 되는 것인가… 또 울기 시작한 페페… (그만 울어잇!) 의미있는 경험으로 남기기위해 기록해보자. 데드락이 발생하는 상황 다시 재현 현재 테이블 상태 CREATE TABLE parent ( id bigint not null primary key, name varchar(255) null, updated_at datetime(6) null ); CREATE TABLE child ( id bigint not null primary key, name varchar(255) null, parent_id bigint null, CONSTRAINT parent_id_unique UNIQUE (parent_id) ); CREATE TABLE child_index ( id bigint not null primary key, name varchar(255) null, parent_id bigint null, ); CREATE INDEX parent_id ON child_index (parent_id); INSERT INTO parent VALUES (1, &#39;parent_1&#39;, NOW()); parent 테이블의 id를 index로 가지고 있는 child_index 테이블 생성(외래키는 운영에서 삭제되어서 테스트시 고려하지 않습니다) parent 테이블의 id를 유니크 키로 가지고 있는 child 테이블 생성(마찬가지로 외래키 고려하지 않습니다.) parent 테이블에 테스트 데이터 적재 그럼 이제 데드락을 발생시켜 보자 index 걸려있는 row delete → index 걸려있는 자식 row insert가 두개의 세션에서 수행되면, 데드락이 발생 💣 TX1 TX2 lock BEGIN ; DELETE FROM child_index WHERE parent_id = 2;   (1) child X Lock 인데, TX2에서 X Lock 획득 가능할까 🤔   BEGIN ; DELETE FROM child_index WHERE parent_id = 2; (2) child X Lock INSERT INTO child_index VALUES (‘1’, ‘name2’, 2);   (3) child X,INSERT_INTENTION Lock 대기   INSERT INTO child_index VALUES (‘2’, ‘name2’, 2); (4) child X,INSERT_INTENTION Lock 대기   Deadlock found when trying to get lock; try restarting transaction (4) child X lock 이 필요하지만, (2) 에서 child X lock 상태 (4) 해소를 위해서 (3) 해소 필요 -&gt; (3) 해소 위해서 TX2 커밋 필요 -&gt; TX2 커밋하려면 (4) 해소 필요 -&gt; 데드락 발생 운영환경에서 데드락이 발생하는 로직을 살펴보자 index 걸려있는 row delete → index 걸려있는 자식 row insert가 두개의 세션에서 수행되면, 데드락이 발생 💣 SELECT * from parent WHERE id = 1; INSERT INTO child VALUES (1, &#39;child_1&#39;, 1); DELETE FROM child_index WHERE parent_id = 1; INSERT INTO child_index VALUES (1, &#39;child_index_1&#39;, 1); UPDATE parent SET updated_at = NOW() WHERE id = 1; @Transactional public void createChildAndChildIndex (long parentId) { var parent = parentRepository.findById(parentId); childIndexRepository.deleteByParent(parent); childIndexRepository.save(new Child_Index(&#39;child_index_1&#39;, parent)); } 한가지 신기한 점은 delete 하려는 데이터가 없을 때, 데드락이 발생한다. delete 하려는 데이터가 있는 경우에는 같은 로직을 수행하면 락을 잡을 때까지 기다리게 된다. 원인은 알았고, 서버에서 데드락을 해결할 수 있는 방법을 고민해보자 ❎ 첫번째 시도, 존재하는 경우에만 row 삭제 @Transactional public void createParent (long parentId) { var parent = parentRepository.findById(parentId); if(childIndexRepository.findByParent(parent).isPresent()) { childIndexRepository.deleteByParent(parent); } childIndexRepository.save(new Child_Index(&#39;child_index_1&#39;, parent)); } 무조건 delete 하는 로직으로 인한 배타락은 방지 가능하다. 동시 요청시에 childIndexRepository.findByParent 에 데이터가 없는 경우로 분기처리되는 경우, 데이터가 2배로 적재될 수 있다. 300ms 로 쓰레드 sleep() 걸어서 테스트 결과 2배로 쌓이는 것을 확인 ✅ 두번째 시도, 존재하는 경우에만 row 삭제하면서 유니크 조건 추가 CREATE TABLE child_index ( id bigint not null primary key, name varchar(255) null, parent_id bigint null, CONSTRAINT parent_id_unique UNIQUE (parent_id) ); CREATE INDEX parent_id ON child_index (parent_id); 동시 요청시에 childIndexRepository.findByParent 에 데이터가 없는 경우로 분기처리되는 경우, 후에 커밋되어 적재된 데이터는 중복키 에러 처리된다. ❎ 세번째 시도, Redis 에 동시성 제어를 위한 키 추가 간헐적인 데드락이고, 위 서비스에서 Redis를 사용하지 않아 캐시 리소스가 더 클 것 같아 나가리! ❎ 네번째 시도, 요청 제한 Bucket4j를 이용해서 클라이언트가 특정 시간 프레임 내에 만들 수 있는 API 호출 수를 제한한다. 위 서비스는 서버가 여러대인 경우라서 다른 서버로 동시 요청이 들어가는 경우, 데드락 방지 불가능 정리 데이터가 없는 경우, 삭제 쿼리를 날리면 delete, select 는 가능하지만 insert 시에 락을 기다리게 된다. 락이 궁금하다면, MySQL 공식문서 중 InnoDB Lock 메뉴얼을 참고해보자. (예제와 함께 정리가 너무 잘 되어있는 것을 볼 수 있다.) 흥미로운 실험 인덱스가 걸린 컬럼 기준으로 쿼리 데이터가 있는 경우에는, 2번째 트랜잭션에서 delete 시에 락 획득을 기다린다. BEGIN ; DELETE FROM child_index WHERE parent_id = 1; INSERT INTO child_index VALUES (1, &#39;child_index_1&#39;, 1); COMMIT ; 데이터가 없는 경우에는, 2번째 트랜잭션에서 delete 시에 락 획득이 바로 가능하다. BEGIN ; DELETE FROM child_index WHERE parent_id = 1; INSERT INTO child_index VALUES (1, &#39;child_index_1&#39;, 1); COMMIT ; 인덱스가 걸리지 않은 컬럼 기준으로 쿼리 데이터가 있는 / 없는 경우, 2번째 트랜잭션에서 delete 시에 락 획득을 기다린다. BEGIN ; DELETE FROM child_index WHERE name = &#39;child_index_2&#39;; INSERT INTO child_index VALUES (1, &#39;child_index_1&#39;, 1); COMMIT ; 기록용 SHOW ENGINE innodb STATUS; *** (1) TRANSACTION:TRANSACTION 13034, ACTIVE 6 sec insertingmysql tables in use 1, locked 1LOCK WAIT 4 lock struct(s), heap size 1128, 3 row lock(s), undo log entries 1MySQL thread id 280, OS thread handle 6136639488, query id 21716 localhost 127.0.0.1 root update/* ApplicationName=DataGrip 2022.3.2 */ insert into child values (&#39;2&#39;, &#39;name2&#39;, 2) *** (1) HOLDS THE LOCK(S):RECORD LOCKS space id 154 page no 4 n bits 72 index PRIMARY of table jpa.child trx id 13034 lock_mode X locks rec but not gapRecord lock, heap no 3 PHYSICAL RECORD: n_fields 5; compact format; info bits 0 *** (1) WAITING FOR THIS LOCK TO BE GRANTED:RECORD LOCKS space id 154 page no 5 n bits 72 index parent_id of table jpa.child trx id 13034 lock_mode X insert intention waitingRecord lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0 *** (2) TRANSACTION:TRANSACTION 13035, ACTIVE 4 sec insertingmysql tables in use 1, locked 1LOCK WAIT 3 lock struct(s), heap size 1128, 2 row lock(s)MySQL thread id 281, OS thread handle 6135525376, query id 21726 localhost 127.0.0.1 root update/* ApplicationName=DataGrip 2022.3.2 */ insert into child values (&#39;2&#39;, &#39;name2&#39;, 2) *** (2) HOLDS THE LOCK(S):RECORD LOCKS space id 154 page no 5 n bits 72 index parent_id of table jpa.child trx id 13035 lock_mode XRecord lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0 *** (2) WAITING FOR THIS LOCK TO BE GRANTED:RECORD LOCKS space id 154 page no 4 n bits 72 index PRIMARY of table jpa.child trx id 13035 lock mode S locks rec but not gap waitingRecord lock, heap no 3 PHYSICAL RECORD: n_fields 5; compact format; info bits 0 - SELECT * FROM performance_schema.data_locks; | INDEX\_NAME | OBJECT\_INSTANCE\_BEGIN | LOCK\_TYPE | LOCK\_MODE | LOCK\_STATUS | LOCK\_DATA | | :--- | :--- | :--- | :--- | :--- | :--- | | null | 4813003272 | TABLE | IX | GRANTED | null | | parent\_id | 4823656472 | RECORD | X | GRANTED | supremum pseudo-record | | parent\_id | 4823656816 | RECORD | X,INSERT\_INTENTION | GRANTED | supremum pseudo-record | | parent\_id | 4823657160 | RECORD | X,GAP | GRANTED | 1, 1 |" />
<link rel="canonical" href="https://hocaron.github.io/ko/dead-lock-by-index/" />
<meta property="og:url" content="https://hocaron.github.io/dead-lock-by-index/" />
<meta property="og:site_name" content="this.hocaron" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-05-23T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="[Troubleshooting - DB] 인덱스(Index)와 데드락(DeadLock)" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Hocaron","url":"https://hocaron.github.io"},"dateModified":"2023-05-23T00:00:00+00:00","datePublished":"2023-05-23T00:00:00+00:00","description":"역시 해치웠나를 외치면 안 되는 것인가… 또 울기 시작한 페페… (그만 울어잇!) 의미있는 경험으로 남기기위해 기록해보자. 데드락이 발생하는 상황 다시 재현 현재 테이블 상태 CREATE TABLE parent ( id bigint not null primary key, name varchar(255) null, updated_at datetime(6) null ); CREATE TABLE child ( id bigint not null primary key, name varchar(255) null, parent_id bigint null, CONSTRAINT parent_id_unique UNIQUE (parent_id) ); CREATE TABLE child_index ( id bigint not null primary key, name varchar(255) null, parent_id bigint null, ); CREATE INDEX parent_id ON child_index (parent_id); INSERT INTO parent VALUES (1, &#39;parent_1&#39;, NOW()); parent 테이블의 id를 index로 가지고 있는 child_index 테이블 생성(외래키는 운영에서 삭제되어서 테스트시 고려하지 않습니다) parent 테이블의 id를 유니크 키로 가지고 있는 child 테이블 생성(마찬가지로 외래키 고려하지 않습니다.) parent 테이블에 테스트 데이터 적재 그럼 이제 데드락을 발생시켜 보자 index 걸려있는 row delete → index 걸려있는 자식 row insert가 두개의 세션에서 수행되면, 데드락이 발생 💣 TX1 TX2 lock BEGIN ; DELETE FROM child_index WHERE parent_id = 2;   (1) child X Lock 인데, TX2에서 X Lock 획득 가능할까 🤔   BEGIN ; DELETE FROM child_index WHERE parent_id = 2; (2) child X Lock INSERT INTO child_index VALUES (‘1’, ‘name2’, 2);   (3) child X,INSERT_INTENTION Lock 대기   INSERT INTO child_index VALUES (‘2’, ‘name2’, 2); (4) child X,INSERT_INTENTION Lock 대기   Deadlock found when trying to get lock; try restarting transaction (4) child X lock 이 필요하지만, (2) 에서 child X lock 상태 (4) 해소를 위해서 (3) 해소 필요 -&gt; (3) 해소 위해서 TX2 커밋 필요 -&gt; TX2 커밋하려면 (4) 해소 필요 -&gt; 데드락 발생 운영환경에서 데드락이 발생하는 로직을 살펴보자 index 걸려있는 row delete → index 걸려있는 자식 row insert가 두개의 세션에서 수행되면, 데드락이 발생 💣 SELECT * from parent WHERE id = 1; INSERT INTO child VALUES (1, &#39;child_1&#39;, 1); DELETE FROM child_index WHERE parent_id = 1; INSERT INTO child_index VALUES (1, &#39;child_index_1&#39;, 1); UPDATE parent SET updated_at = NOW() WHERE id = 1; @Transactional public void createChildAndChildIndex (long parentId) { var parent = parentRepository.findById(parentId); childIndexRepository.deleteByParent(parent); childIndexRepository.save(new Child_Index(&#39;child_index_1&#39;, parent)); } 한가지 신기한 점은 delete 하려는 데이터가 없을 때, 데드락이 발생한다. delete 하려는 데이터가 있는 경우에는 같은 로직을 수행하면 락을 잡을 때까지 기다리게 된다. 원인은 알았고, 서버에서 데드락을 해결할 수 있는 방법을 고민해보자 ❎ 첫번째 시도, 존재하는 경우에만 row 삭제 @Transactional public void createParent (long parentId) { var parent = parentRepository.findById(parentId); if(childIndexRepository.findByParent(parent).isPresent()) { childIndexRepository.deleteByParent(parent); } childIndexRepository.save(new Child_Index(&#39;child_index_1&#39;, parent)); } 무조건 delete 하는 로직으로 인한 배타락은 방지 가능하다. 동시 요청시에 childIndexRepository.findByParent 에 데이터가 없는 경우로 분기처리되는 경우, 데이터가 2배로 적재될 수 있다. 300ms 로 쓰레드 sleep() 걸어서 테스트 결과 2배로 쌓이는 것을 확인 ✅ 두번째 시도, 존재하는 경우에만 row 삭제하면서 유니크 조건 추가 CREATE TABLE child_index ( id bigint not null primary key, name varchar(255) null, parent_id bigint null, CONSTRAINT parent_id_unique UNIQUE (parent_id) ); CREATE INDEX parent_id ON child_index (parent_id); 동시 요청시에 childIndexRepository.findByParent 에 데이터가 없는 경우로 분기처리되는 경우, 후에 커밋되어 적재된 데이터는 중복키 에러 처리된다. ❎ 세번째 시도, Redis 에 동시성 제어를 위한 키 추가 간헐적인 데드락이고, 위 서비스에서 Redis를 사용하지 않아 캐시 리소스가 더 클 것 같아 나가리! ❎ 네번째 시도, 요청 제한 Bucket4j를 이용해서 클라이언트가 특정 시간 프레임 내에 만들 수 있는 API 호출 수를 제한한다. 위 서비스는 서버가 여러대인 경우라서 다른 서버로 동시 요청이 들어가는 경우, 데드락 방지 불가능 정리 데이터가 없는 경우, 삭제 쿼리를 날리면 delete, select 는 가능하지만 insert 시에 락을 기다리게 된다. 락이 궁금하다면, MySQL 공식문서 중 InnoDB Lock 메뉴얼을 참고해보자. (예제와 함께 정리가 너무 잘 되어있는 것을 볼 수 있다.) 흥미로운 실험 인덱스가 걸린 컬럼 기준으로 쿼리 데이터가 있는 경우에는, 2번째 트랜잭션에서 delete 시에 락 획득을 기다린다. BEGIN ; DELETE FROM child_index WHERE parent_id = 1; INSERT INTO child_index VALUES (1, &#39;child_index_1&#39;, 1); COMMIT ; 데이터가 없는 경우에는, 2번째 트랜잭션에서 delete 시에 락 획득이 바로 가능하다. BEGIN ; DELETE FROM child_index WHERE parent_id = 1; INSERT INTO child_index VALUES (1, &#39;child_index_1&#39;, 1); COMMIT ; 인덱스가 걸리지 않은 컬럼 기준으로 쿼리 데이터가 있는 / 없는 경우, 2번째 트랜잭션에서 delete 시에 락 획득을 기다린다. BEGIN ; DELETE FROM child_index WHERE name = &#39;child_index_2&#39;; INSERT INTO child_index VALUES (1, &#39;child_index_1&#39;, 1); COMMIT ; 기록용 SHOW ENGINE innodb STATUS; *** (1) TRANSACTION:TRANSACTION 13034, ACTIVE 6 sec insertingmysql tables in use 1, locked 1LOCK WAIT 4 lock struct(s), heap size 1128, 3 row lock(s), undo log entries 1MySQL thread id 280, OS thread handle 6136639488, query id 21716 localhost 127.0.0.1 root update/* ApplicationName=DataGrip 2022.3.2 */ insert into child values (&#39;2&#39;, &#39;name2&#39;, 2) *** (1) HOLDS THE LOCK(S):RECORD LOCKS space id 154 page no 4 n bits 72 index PRIMARY of table jpa.child trx id 13034 lock_mode X locks rec but not gapRecord lock, heap no 3 PHYSICAL RECORD: n_fields 5; compact format; info bits 0 *** (1) WAITING FOR THIS LOCK TO BE GRANTED:RECORD LOCKS space id 154 page no 5 n bits 72 index parent_id of table jpa.child trx id 13034 lock_mode X insert intention waitingRecord lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0 *** (2) TRANSACTION:TRANSACTION 13035, ACTIVE 4 sec insertingmysql tables in use 1, locked 1LOCK WAIT 3 lock struct(s), heap size 1128, 2 row lock(s)MySQL thread id 281, OS thread handle 6135525376, query id 21726 localhost 127.0.0.1 root update/* ApplicationName=DataGrip 2022.3.2 */ insert into child values (&#39;2&#39;, &#39;name2&#39;, 2) *** (2) HOLDS THE LOCK(S):RECORD LOCKS space id 154 page no 5 n bits 72 index parent_id of table jpa.child trx id 13035 lock_mode XRecord lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0 *** (2) WAITING FOR THIS LOCK TO BE GRANTED:RECORD LOCKS space id 154 page no 4 n bits 72 index PRIMARY of table jpa.child trx id 13035 lock mode S locks rec but not gap waitingRecord lock, heap no 3 PHYSICAL RECORD: n_fields 5; compact format; info bits 0 - SELECT * FROM performance_schema.data_locks; | INDEX\\_NAME | OBJECT\\_INSTANCE\\_BEGIN | LOCK\\_TYPE | LOCK\\_MODE | LOCK\\_STATUS | LOCK\\_DATA | | :--- | :--- | :--- | :--- | :--- | :--- | | null | 4813003272 | TABLE | IX | GRANTED | null | | parent\\_id | 4823656472 | RECORD | X | GRANTED | supremum pseudo-record | | parent\\_id | 4823656816 | RECORD | X,INSERT\\_INTENTION | GRANTED | supremum pseudo-record | | parent\\_id | 4823657160 | RECORD | X,GAP | GRANTED | 1, 1 |","headline":"[Troubleshooting - DB] 인덱스(Index)와 데드락(DeadLock)","mainEntityOfPage":{"@type":"WebPage","@id":"https://hocaron.github.io/dead-lock-by-index/"},"url":"https://hocaron.github.io/dead-lock-by-index/"}</script>
<!-- End Jekyll SEO tag -->


  <!-- CSS -->
  <link rel="stylesheet" href="/ko/assets/main.css">
  <link rel="stylesheet" href="../assets/main.js">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.1/css/all.min.css" />

  <!-- Favicon -->
  <link rel="icon" type="image/png" sizes="32x32" href="/ko/assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/ko/assets/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/ko/assets/apple-touch-icon.png">

  <!-- RSS -->
  <link type="application/atom+xml" rel="alternate" href="https://hocaron.github.io/ko/feed.xml" title="this.hocaron" />

  <!-- Google Analytics-->
  
  <script>
  window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
  ga('create', 'UA—XXXXXXXX-X', 'auto');
  ga('send', 'pageview');
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  

  <!-- JavaScript -->
  <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
  <script type="text/javascript" src="../assets/main.js"></script>

  <!-- SEO for Polyglot -->
  
</head>


<body>
<div>
  




<nav class="nav">
  <div class="nav-container">
    <a href="/ko/">
      <h2 class="nav-title">this.hocaron</h2>
    </a>
    <ul>
      <li class="selected">
      <a href="/ko/">Posts</a>
      </li>
      <li >
        <a href="/ko/series">Series</a>
      </li>
      <li >
        <a href="/ko/about">About</a>
      </li>

      <li>
        
        
        
        <a class="lang active"
           href="
                /ko/dead-lock-by-index/
              ">
          KOR
          |
        </a>
        
        
        
        <a class="lang "
           href="
                /dead-lock-by-index/
              ">
          ENG
          
        </a>
        
      </li>

    </ul>
  </div>
</nav>


  <main>
    <div class="post">
  <div class="post-info">
<!--    <span>Written by</span>-->
<!--    -->
<!--        Hocaron-->
<!--    -->

    
      <br>
      <span>on&nbsp;</span><time datetime="2023-05-23 00:00:00 +0000">May 23, 2023</time>
    
  </div>

  <h1 class="post-title">[Troubleshooting - DB] 인덱스(Index)와 데드락(DeadLock)</h1>
<!--  <div class="post-line"></div>-->
  <article class="post-article">
    <div class="toc">
      <ul><li><a href="#데드락이-발생하는-상황-다시-재현">데드락이 발생하는 상황 다시 재현</a><ul><li><a href="#현재-테이블-상태">현재 테이블 상태</a></li><li><a href="#그럼-이제-데드락을-발생시켜-보자">그럼 이제 데드락을 발생시켜 보자</a></li><li><a href="#index-걸려있는-row-delete---index-걸려있는-자식-row-insert가-두개의-세션에서-수행되면-데드락이-발생-">index 걸려있는 row delete →  index 걸려있는 자식 row insert가 두개의 세션에서 수행되면, 데드락이 발생 💣</a></li></ul></li><li><a href="#운영환경에서-데드락이-발생하는-로직을-살펴보자">운영환경에서 데드락이 발생하는 로직을 살펴보자</a><ul><li><a href="#index-걸려있는-row-delete---index-걸려있는-자식-row-insert가-두개의-세션에서-수행되면-데드락이-발생--1">index 걸려있는 row delete →  index 걸려있는 자식 row insert가 두개의 세션에서 수행되면, 데드락이 발생 💣</a></li></ul></li><li><a href="#원인은-알았고-서버에서-데드락을-해결할-수-있는-방법을-고민해보자">원인은 알았고, 서버에서 데드락을 해결할 수 있는 방법을 고민해보자</a><ul><li><a href="#-첫번째-시도-존재하는-경우에만-row-삭제">❎ 첫번째 시도, 존재하는 경우에만 row 삭제</a></li><li><a href="#-두번째-시도-존재하는-경우에만-row-삭제하면서-유니크-조건-추가">✅ 두번째 시도, 존재하는 경우에만 row 삭제하면서 유니크 조건 추가</a></li><li><a href="#-세번째-시도-redis-에-동시성-제어를-위한-키-추가">❎ 세번째 시도, Redis 에 동시성 제어를 위한 키 추가</a></li><li><a href="#-네번째-시도-요청-제한">❎ 네번째 시도, 요청 제한</a></li></ul></li><li><a href="#정리">정리</a><ul><li><a href="#흥미로운-실험">흥미로운 실험</a><ul><li><a href="#인덱스가-걸린-컬럼-기준으로-쿼리">인덱스가 걸린 컬럼 기준으로 쿼리</a></li><li><a href="#인덱스가-걸리지-않은-컬럼-기준으로-쿼리">인덱스가 걸리지 않은 컬럼 기준으로 쿼리</a></li></ul></li><li><a href="#기록용">기록용</a></li></ul></li></ul>

    </div>
    <p><img src="https://velog.velcdn.com/images/haron/post/329afb75-8be4-47ed-ab19-cb087ec1a934/image.png" alt="" /></p>

<p>역시 <a href="https://velog.io/@haron/%EC%99%B8%EB%9E%98%ED%82%A4Foreign-Key%EC%99%80-%EB%8D%B0%EB%93%9C%EB%9D%BDDeadLock-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%BF%BC%EB%A6%AC-%EC%A7%80%EC%97%B0-%EC%8B%A4%ED%96%89-eruedsy4">해치웠나</a>를 외치면 안 되는 것인가… 또 울기 시작한 페페… (그만 울어잇!)
의미있는 경험으로 남기기위해 기록해보자.
<img src="https://velog.velcdn.com/images/haron/post/1687c152-873d-425f-96f9-174735a9c262/image.png" alt="" /></p>

<h2 id="데드락이-발생하는-상황-다시-재현">데드락이 발생하는 상황 다시 재현</h2>

<h3 id="현재-테이블-상태">현재 테이블 상태</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">parent</span>
<span class="p">(</span>
    <span class="n">id</span>             <span class="nb">bigint</span>        <span class="k">not</span> <span class="k">null</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>
    <span class="n">name</span>           <span class="nb">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span>  <span class="k">null</span><span class="p">,</span>
    <span class="n">updated_at</span>     <span class="nb">datetime</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>   <span class="k">null</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">child</span>
<span class="p">(</span>
    <span class="n">id</span>           <span class="nb">bigint</span>          <span class="k">not</span> <span class="k">null</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>
    <span class="n">name</span>         <span class="nb">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span>    <span class="k">null</span><span class="p">,</span>
    <span class="n">parent_id</span>    <span class="nb">bigint</span>          <span class="k">null</span><span class="p">,</span>
    <span class="k">CONSTRAINT</span> <span class="n">parent_id_unique</span> <span class="k">UNIQUE</span> <span class="p">(</span><span class="n">parent_id</span><span class="p">)</span>
<span class="p">);</span>


<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">child_index</span>
<span class="p">(</span>
    <span class="n">id</span>           <span class="nb">bigint</span>          <span class="k">not</span> <span class="k">null</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>
    <span class="n">name</span>         <span class="nb">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span>    <span class="k">null</span><span class="p">,</span>
    <span class="n">parent_id</span>    <span class="nb">bigint</span>          <span class="k">null</span><span class="p">,</span>
<span class="p">);</span>
<span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">parent_id</span> <span class="k">ON</span> <span class="n">child_index</span> <span class="p">(</span><span class="n">parent_id</span><span class="p">);</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">parent</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'parent_1'</span><span class="p">,</span> <span class="n">NOW</span><span class="p">());</span>
</code></pre></div></div>
<ol>
  <li>parent 테이블의 id를 index로 가지고 있는 child_index 테이블 생성(외래키는 운영에서 삭제되어서 테스트시 고려하지 않습니다)</li>
  <li>parent 테이블의 id를 유니크 키로 가지고 있는 child 테이블 생성(마찬가지로 외래키 고려하지 않습니다.)</li>
  <li>parent 테이블에 테스트 데이터 적재</li>
</ol>

<h3 id="그럼-이제-데드락을-발생시켜-보자">그럼 이제 데드락을 발생시켜 보자</h3>
<h3 id="index-걸려있는-row-delete---index-걸려있는-자식-row-insert가-두개의-세션에서-수행되면-데드락이-발생-">index 걸려있는 row delete →  index 걸려있는 자식 row insert가 두개의 세션에서 수행되면, 데드락이 발생 💣</h3>
<p><img src="https://velog.velcdn.com/images/haron/post/bc47166e-b1b7-4f30-ac1f-09932cb38ff7/image.png" alt="" /></p>

<table>
  <thead>
    <tr>
      <th>TX1</th>
      <th>TX2</th>
      <th>lock</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>BEGIN ;  <br /> DELETE FROM child_index WHERE parent_id = 2;</td>
      <td> </td>
      <td>(1) child X Lock 인데, TX2에서 X Lock 획득 가능할까 🤔</td>
    </tr>
    <tr>
      <td> </td>
      <td>BEGIN ;  <br /> DELETE FROM child_index WHERE parent_id = 2;</td>
      <td>(2) child X Lock</td>
    </tr>
    <tr>
      <td>INSERT INTO child_index VALUES (‘1’, ‘name2’, 2);</td>
      <td> </td>
      <td>(3) child X,INSERT_INTENTION Lock 대기</td>
    </tr>
    <tr>
      <td> </td>
      <td>INSERT INTO child_index VALUES (‘2’, ‘name2’, 2);</td>
      <td>(4) child X,INSERT_INTENTION Lock 대기</td>
    </tr>
    <tr>
      <td> </td>
      <td>Deadlock found when trying to get lock; try restarting transaction</td>
      <td>(4) child X lock 이 필요하지만, (2) 에서 child X lock 상태 <br /> (4) 해소를 위해서 (3) 해소 필요 <br /> -&gt; (3) 해소 위해서 TX2 커밋 필요 <br /> -&gt; TX2 커밋하려면 (4) 해소 필요 <br /> -&gt; 데드락 발생</td>
    </tr>
  </tbody>
</table>

<h2 id="운영환경에서-데드락이-발생하는-로직을-살펴보자">운영환경에서 데드락이 발생하는 로직을 살펴보자</h2>

<h3 id="index-걸려있는-row-delete---index-걸려있는-자식-row-insert가-두개의-세션에서-수행되면-데드락이-발생--1">index 걸려있는 row delete →  index 걸려있는 자식 row insert가 두개의 세션에서 수행되면, 데드락이 발생 💣</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">from</span> <span class="n">parent</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">child</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'child_1'</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">DELETE</span> <span class="k">FROM</span> <span class="n">child_index</span> <span class="k">WHERE</span> <span class="n">parent_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">child_index</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'child_index_1'</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">UPDATE</span> <span class="n">parent</span> <span class="k">SET</span>  <span class="n">updated_at</span> <span class="o">=</span> <span class="n">NOW</span><span class="p">()</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@Transactional</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createChildAndChildIndex</span> <span class="o">(</span><span class="kt">long</span> <span class="n">parentId</span><span class="o">)</span> <span class="o">{</span>

    <span class="kt">var</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">parentRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">parentId</span><span class="o">);</span>
    
    <span class="n">childIndexRepository</span><span class="o">.</span><span class="na">deleteByParent</span><span class="o">(</span><span class="n">parent</span><span class="o">);</span>
    <span class="n">childIndexRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="k">new</span> <span class="n">Child_Index</span><span class="o">(</span><span class="err">'</span><span class="n">child_index_1</span><span class="err">'</span><span class="o">,</span> <span class="n">parent</span><span class="o">));</span>

  <span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>한가지 신기한 점은 delete 하려는 데이터가 없을 때, 데드락이 발생한다.</li>
  <li>delete 하려는 데이터가 있는 경우에는 같은 로직을 수행하면 락을 잡을 때까지 기다리게 된다.</li>
</ul>

<h2 id="원인은-알았고-서버에서-데드락을-해결할-수-있는-방법을-고민해보자">원인은 알았고, 서버에서 데드락을 해결할 수 있는 방법을 고민해보자</h2>
<h3 id="-첫번째-시도-존재하는-경우에만-row-삭제">❎ 첫번째 시도, 존재하는 경우에만 row 삭제</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@Transactional</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createParent</span> <span class="o">(</span><span class="kt">long</span> <span class="n">parentId</span><span class="o">)</span> <span class="o">{</span>

    <span class="kt">var</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">parentRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">parentId</span><span class="o">);</span>
    
    <span class="k">if</span><span class="o">(</span><span class="n">childIndexRepository</span><span class="o">.</span><span class="na">findByParent</span><span class="o">(</span><span class="n">parent</span><span class="o">).</span><span class="na">isPresent</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">childIndexRepository</span><span class="o">.</span><span class="na">deleteByParent</span><span class="o">(</span><span class="n">parent</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="n">childIndexRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="k">new</span> <span class="n">Child_Index</span><span class="o">(</span><span class="err">'</span><span class="n">child_index_1</span><span class="err">'</span><span class="o">,</span> <span class="n">parent</span><span class="o">));</span>
  <span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>무조건 delete 하는 로직으로 인한 배타락은 방지 가능하다.</li>
  <li>동시 요청시에 childIndexRepository.findByParent 에 데이터가 없는 경우로 분기처리되는 경우, 데이터가 2배로 적재될 수 있다.
    <ul>
      <li>300ms 로 쓰레드 sleep() 걸어서 테스트 결과 2배로 쌓이는 것을 확인</li>
    </ul>
  </li>
</ul>

<h3 id="-두번째-시도-존재하는-경우에만-row-삭제하면서-유니크-조건-추가">✅ 두번째 시도, 존재하는 경우에만 row 삭제하면서 유니크 조건 추가</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">child_index</span>
<span class="p">(</span>
    <span class="n">id</span>           <span class="nb">bigint</span>          <span class="k">not</span> <span class="k">null</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>
    <span class="n">name</span>         <span class="nb">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span>    <span class="k">null</span><span class="p">,</span>
    <span class="n">parent_id</span>    <span class="nb">bigint</span>          <span class="k">null</span><span class="p">,</span>
    <span class="k">CONSTRAINT</span> <span class="n">parent_id_unique</span> <span class="k">UNIQUE</span> <span class="p">(</span><span class="n">parent_id</span><span class="p">)</span>
<span class="p">);</span>
<span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">parent_id</span> <span class="k">ON</span> <span class="n">child_index</span> <span class="p">(</span><span class="n">parent_id</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li>동시 요청시에 childIndexRepository.findByParent 에 데이터가 없는 경우로 분기처리되는 경우, 후에 커밋되어 적재된 데이터는 중복키 에러 처리된다.</li>
</ul>

<h3 id="-세번째-시도-redis-에-동시성-제어를-위한-키-추가">❎ 세번째 시도, Redis 에 동시성 제어를 위한 키 추가</h3>
<ul>
  <li>간헐적인 데드락이고, 위 서비스에서 Redis를 사용하지 않아 캐시 리소스가 더 클 것 같아 나가리!</li>
</ul>

<h3 id="-네번째-시도-요청-제한">❎ 네번째 시도, 요청 제한</h3>
<ul>
  <li>Bucket4j를 이용해서 클라이언트가 특정 시간 프레임 내에 만들 수 있는 API 호출 수를 제한한다.</li>
  <li>위 서비스는 서버가 여러대인 경우라서 다른 서버로 동시 요청이 들어가는 경우, 데드락 방지 불가능</li>
</ul>

<h2 id="정리">정리</h2>
<ol>
  <li>데이터가 없는 경우, 삭제 쿼리를 날리면 delete, select 는 가능하지만 insert 시에 락을 기다리게 된다.</li>
  <li>락이 궁금하다면, <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-record-locks">MySQL 공식문서 중 InnoDB Lock 메뉴얼</a>을 참고해보자. (예제와 함께 정리가 너무 잘 되어있는 것을 볼 수 있다.)</li>
</ol>

<h3 id="흥미로운-실험">흥미로운 실험</h3>
<h4 id="인덱스가-걸린-컬럼-기준으로-쿼리">인덱스가 걸린 컬럼 기준으로 쿼리</h4>
<ul>
  <li>데이터가 있는 경우에는, 2번째 트랜잭션에서 delete 시에 락 획득을 기다린다.
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">BEGIN</span> <span class="p">;</span>
<span class="k">DELETE</span> <span class="k">FROM</span> <span class="n">child_index</span> <span class="k">WHERE</span> <span class="n">parent_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">child_index</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'child_index_1'</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">COMMIT</span> <span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>데이터가 없는 경우에는, 2번째 트랜잭션에서 delete 시에 락 획득이 바로 가능하다.
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">BEGIN</span> <span class="p">;</span>
<span class="k">DELETE</span> <span class="k">FROM</span> <span class="n">child_index</span> <span class="k">WHERE</span> <span class="n">parent_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">child_index</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'child_index_1'</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">COMMIT</span> <span class="p">;</span>
</code></pre></div>    </div>
    <h4 id="인덱스가-걸리지-않은-컬럼-기준으로-쿼리">인덱스가 걸리지 않은 컬럼 기준으로 쿼리</h4>
  </li>
  <li>데이터가 있는 / 없는 경우, 2번째 트랜잭션에서 delete 시에 락 획득을 기다린다.
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">BEGIN</span> <span class="p">;</span>
<span class="k">DELETE</span> <span class="k">FROM</span> <span class="n">child_index</span> <span class="k">WHERE</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">'child_index_2'</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">child_index</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'child_index_1'</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">COMMIT</span> <span class="p">;</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="기록용">기록용</h3>
<details>
<summary>SHOW ENGINE innodb STATUS;</summary>
  *** (1) TRANSACTION:TRANSACTION 13034, ACTIVE 6 sec insertingmysql tables in use 1, locked 1LOCK WAIT 4 lock struct(s), heap size 1128, 3 row lock(s), undo log entries 1MySQL thread id 280, OS thread handle 6136639488, query id 21716 localhost 127.0.0.1 root update/* ApplicationName=DataGrip 2022.3.2 */ insert into child values ('2', 'name2', 2)

*** (1) HOLDS THE LOCK(S):RECORD LOCKS space id 154 page no 4 n bits 72 index PRIMARY of table jpa.child trx id 13034 lock_mode X locks rec but not gapRecord lock, heap no 3 PHYSICAL RECORD: n_fields 5; compact format; info bits 0

*** (1) WAITING FOR THIS LOCK TO BE GRANTED:RECORD LOCKS space id 154 page no 5 n bits 72 index parent_id of table jpa.child trx id 13034 lock_mode X insert intention waitingRecord lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0

*** (2) TRANSACTION:TRANSACTION 13035, ACTIVE 4 sec insertingmysql tables in use 1, locked 1LOCK WAIT 3 lock struct(s), heap size 1128, 2 row lock(s)MySQL thread id 281, OS thread handle 6135525376, query id 21726 localhost 127.0.0.1 root update/* ApplicationName=DataGrip 2022.3.2 */ insert into child values ('2', 'name2', 2)

*** (2) HOLDS THE LOCK(S):RECORD LOCKS space id 154 page no 5 n bits 72 index parent_id of table jpa.child trx id 13035 lock_mode XRecord lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0

*** (2) WAITING FOR THIS LOCK TO BE GRANTED:RECORD LOCKS space id 154 page no 4 n bits 72 index PRIMARY of table jpa.child trx id 13035 lock mode S locks rec but not gap waitingRecord lock, heap no 3 PHYSICAL RECORD: n_fields 5; compact format; info bits 0

- SELECT * FROM performance_schema.data_locks;

| INDEX\_NAME | OBJECT\_INSTANCE\_BEGIN | LOCK\_TYPE | LOCK\_MODE | LOCK\_STATUS | LOCK\_DATA |
| :--- | :--- | :--- | :--- | :--- | :--- |
| null | 4813003272 | TABLE | IX | GRANTED | null |
| parent\_id | 4823656472 | RECORD | X | GRANTED | supremum pseudo-record |
| parent\_id | 4823656816 | RECORD | X,INSERT\_INTENTION | GRANTED | supremum pseudo-record |
| parent\_id | 4823657160 | RECORD | X,GAP | GRANTED | 1, 1 |
</details>

  </article>
</div>

<div class="pagination">
  
  
    <a href="/ko/dead-lock-by-fk/" class="right arrow">&#8594;</a>
  

  
  <!-- Start giscus -->
<script src="https://giscus.app/client.js"
        data-repo="hocaron/hocaron.github.io"
        data-repo-id="R_kgDOL3mLWw"
        data-category="Comments"
        data-category-id="DIC_kwDOL3mLW84CfNm5"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="light"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>
<!-- End giscus -->

  

  <a href="#" class="top">Top</a>
</div>

<script src="../assets/js/toc.js"></script>

  </main>

  <footer>
  <a href="mailto:kkannu0407@gmail.com">
    <i class="far fa-envelope fa-fw"></i>
  </a>
  <a href="https://github.com/hocaron" target="_blank">
    <i class="fab fa-github fa-fw"></i>
  </a>
  <a href="https://www.linkedin.com/in/sunwoo-ho-86b45823a" target="_blank">
    <i class="fab fa-linkedin fa-fw"></i>
  </a>

  <br>
  <span>&copy; 2024 Hocaron</span>
</footer>

</div>
</body>
</html>
