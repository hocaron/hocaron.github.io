<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://hocaron.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://hocaron.github.io/" rel="alternate" type="text/html" /><updated>2024-05-19T07:32:40+00:00</updated><id>https://hocaron.github.io/feed.xml</id><title type="html">this.hocaron</title><subtitle>Minimal Jekyll theme for storytellers</subtitle><author><name>Hocaron</name><email>kkannu0407@gmail.com</email></author><entry xml:lang="en"><title type="html">[Troubleshooting - DB] Index and Deadlock</title><link href="https://hocaron.github.io/dead-lock-by-index/" rel="alternate" type="text/html" title="[Troubleshooting - DB] Index and Deadlock" /><published>2023-05-23T00:00:00+00:00</published><updated>2023-05-23T00:00:00+00:00</updated><id>https://hocaron.github.io/dead-lock-by-index-en</id><content type="html" xml:base="https://hocaron.github.io/dead-lock-by-index/"><![CDATA[<h3 id="have-i-defeated-it">Have I Defeated It?</h3>

<p>Pepe starts crying again… (Stop crying!)</p>

<p>Let’s record this as a meaningful experience.</p>

<p><img src="https://velog.velcdn.com/images/haron/post/1687c152-873d-425f-96f9-174735a9c262/image.png" alt="Pepe crying" /></p>

<h2 id="reproducing-the-deadlock-scenario">Reproducing the Deadlock Scenario</h2>

<h3 id="current-table-state">Current Table State</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">parent</span>
<span class="p">(</span>
    <span class="n">id</span>             <span class="nb">bigint</span>        <span class="k">not</span> <span class="k">null</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>
    <span class="n">name</span>           <span class="nb">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span>  <span class="k">null</span><span class="p">,</span>
    <span class="n">updated_at</span>     <span class="nb">datetime</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>   <span class="k">null</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">child</span>
<span class="p">(</span>
    <span class="n">id</span>           <span class="nb">bigint</span>          <span class="k">not</span> <span class="k">null</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>
    <span class="n">name</span>         <span class="nb">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span>    <span class="k">null</span><span class="p">,</span>
    <span class="n">parent_id</span>    <span class="nb">bigint</span>          <span class="k">null</span><span class="p">,</span>
    <span class="k">CONSTRAINT</span> <span class="n">parent_id_unique</span> <span class="k">UNIQUE</span> <span class="p">(</span><span class="n">parent_id</span><span class="p">)</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">child_index</span>
<span class="p">(</span>
    <span class="n">id</span>           <span class="nb">bigint</span>          <span class="k">not</span> <span class="k">null</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>
    <span class="n">name</span>         <span class="nb">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span>    <span class="k">null</span><span class="p">,</span>
    <span class="n">parent_id</span>    <span class="nb">bigint</span>          <span class="k">null</span>
<span class="p">);</span>
<span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">parent_id</span> <span class="k">ON</span> <span class="n">child_index</span> <span class="p">(</span><span class="n">parent_id</span><span class="p">);</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">parent</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'parent_1'</span><span class="p">,</span> <span class="n">NOW</span><span class="p">());</span>
</code></pre></div></div>
<ol>
  <li>Created the <code class="language-plaintext highlighter-rouge">child_index</code> table with <code class="language-plaintext highlighter-rouge">parent_id</code> as an index (foreign key removed for testing).</li>
  <li>Created the <code class="language-plaintext highlighter-rouge">child</code> table with <code class="language-plaintext highlighter-rouge">parent_id</code> as a unique key (foreign key removed for testing).</li>
  <li>Inserted test data into the <code class="language-plaintext highlighter-rouge">parent</code> table.</li>
</ol>

<h3 id="lets-cause-a-deadlock">Let’s Cause a Deadlock</h3>

<p>Performing row delete on <code class="language-plaintext highlighter-rouge">child_index</code> followed by row insert on <code class="language-plaintext highlighter-rouge">child_index</code> in two sessions causes a deadlock 💣</p>

<p><img src="https://velog.velcdn.com/images/haron/post/bc47166e-b1b7-4f30-ac1f-09932cb38ff7/image.png" alt="Deadlock scenario" /></p>

<table>
  <thead>
    <tr>
      <th>TX1</th>
      <th>TX2</th>
      <th>Lock</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>BEGIN ;<br /> DELETE FROM child_index WHERE parent_id = 2;</td>
      <td> </td>
      <td>(1) Child X Lock, but TX2 can acquire X Lock 🤔</td>
    </tr>
    <tr>
      <td> </td>
      <td>BEGIN ;<br /> DELETE FROM child_index WHERE parent_id = 2;</td>
      <td>(2) Child X Lock</td>
    </tr>
    <tr>
      <td>INSERT INTO child_index VALUES (‘1’, ‘name2’, 2);</td>
      <td> </td>
      <td>(3) Waiting for Child X, INSERT_INTENTION Lock</td>
    </tr>
    <tr>
      <td> </td>
      <td>INSERT INTO child_index VALUES (‘2’, ‘name2’, 2);</td>
      <td>(4) Waiting for Child X, INSERT_INTENTION Lock</td>
    </tr>
    <tr>
      <td> </td>
      <td>Deadlock found when trying to get lock; try restarting transaction</td>
      <td>(4) Needs Child X lock, but (2) holds Child X lock <br /> To resolve (4), (3) must resolve <br /> To resolve (3), TX2 must commit <br /> To commit TX2, (4) must resolve <br /> -&gt; Deadlock occurs</td>
    </tr>
  </tbody>
</table>

<h2 id="examining-the-deadlock-logic-in-production">Examining the Deadlock Logic in Production</h2>

<p>Performing row delete on <code class="language-plaintext highlighter-rouge">child_index</code> followed by row insert on <code class="language-plaintext highlighter-rouge">child_index</code> in two sessions causes a deadlock 💣</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">parent</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">child</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'child_1'</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">DELETE</span> <span class="k">FROM</span> <span class="n">child_index</span> <span class="k">WHERE</span> <span class="n">parent_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">child_index</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'child_index_1'</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">UPDATE</span> <span class="n">parent</span> <span class="k">SET</span> <span class="n">updated_at</span> <span class="o">=</span> <span class="n">NOW</span><span class="p">()</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">createChildAndChildIndex</span><span class="o">(</span><span class="kt">long</span> <span class="n">parentId</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">var</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">parentRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">parentId</span><span class="o">);</span>

    <span class="n">childIndexRepository</span><span class="o">.</span><span class="na">deleteByParent</span><span class="o">(</span><span class="n">parent</span><span class="o">);</span>
    <span class="n">childIndexRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="k">new</span> <span class="n">Child_Index</span><span class="o">(</span><span class="err">'</span><span class="n">child_index_1</span><span class="err">'</span><span class="o">,</span> <span class="n">parent</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>Interestingly, a deadlock occurs when the data to be deleted does not exist.</li>
  <li>When the data to be deleted exists, the lock waits until it can be acquired.</li>
</ul>

<h2 id="solutions-to-resolve-the-deadlock-in-production">Solutions to Resolve the Deadlock in Production</h2>

<h3 id="-first-attempt-delete-row-only-if-it-exists">❎ First Attempt: Delete Row Only If It Exists</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">createParent</span><span class="o">(</span><span class="kt">long</span> <span class="n">parentId</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">var</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">parentRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">parentId</span><span class="o">);</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">childIndexRepository</span><span class="o">.</span><span class="na">findByParent</span><span class="o">(</span><span class="n">parent</span><span class="o">).</span><span class="na">isPresent</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">childIndexRepository</span><span class="o">.</span><span class="na">deleteByParent</span><span class="o">(</span><span class="n">parent</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="n">childIndexRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="k">new</span> <span class="n">Child_Index</span><span class="o">(</span><span class="err">'</span><span class="n">child_index_1</span><span class="err">'</span><span class="o">,</span> <span class="n">parent</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>This prevents the exclusive lock due to the unconditional delete logic.</li>
  <li>If concurrent requests find no data in <code class="language-plaintext highlighter-rouge">childIndexRepository.findByParent</code>, data may be duplicated.
    <ul>
      <li>Testing with a 300ms thread sleep confirmed duplication.</li>
    </ul>
  </li>
</ul>

<h3 id="-second-attempt-delete-row-only-if-it-exists-with-unique-constraint">✅ Second Attempt: Delete Row Only If It Exists with Unique Constraint</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">child_index</span>
<span class="p">(</span>
    <span class="n">id</span>           <span class="nb">bigint</span>          <span class="k">not</span> <span class="k">null</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>
    <span class="n">name</span>         <span class="nb">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span>    <span class="k">null</span><span class="p">,</span>
    <span class="n">parent_id</span>    <span class="nb">bigint</span>          <span class="k">null</span><span class="p">,</span>
    <span class="k">CONSTRAINT</span> <span class="n">parent_id_unique</span> <span class="k">UNIQUE</span> <span class="p">(</span><span class="n">parent_id</span><span class="p">)</span>
<span class="p">);</span>
<span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">parent_id</span> <span class="k">ON</span> <span class="n">child_index</span> <span class="p">(</span><span class="n">parent_id</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li>Concurrent requests with no data found in <code class="language-plaintext highlighter-rouge">childIndexRepository.findByParent</code> result in a duplicate key error for subsequent commits.</li>
</ul>

<h3 id="-third-attempt-add-key-for-concurrency-control-in-redis">❎ Third Attempt: Add Key for Concurrency Control in Redis</h3>
<ul>
  <li>Due to occasional deadlocks and the absence of Redis usage in this service, the cache resource overhead seemed excessive.</li>
</ul>

<h3 id="-fourth-attempt-limit-requests">❎ Fourth Attempt: Limit Requests</h3>
<ul>
  <li>Using Bucket4j to limit the number of API calls a client can make within a specific time frame.</li>
  <li>Deadlock prevention is impossible with multiple servers as concurrent requests can hit different servers.</li>
</ul>

<h2 id="summary">Summary</h2>
<ol>
  <li>When data is not present, delete queries allow delete and select but wait for the lock during insert.</li>
  <li>For more on locks, refer to the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-record-locks">InnoDB Locking Documentation in MySQL Official Manual</a>. It is well-organized with examples.</li>
</ol>

<h3 id="interesting-experiment">Interesting Experiment</h3>
<h4 id="query-based-on-indexed-column">Query Based on Indexed Column</h4>
<ul>
  <li>When data exists, the second transaction waits for the lock during delete.
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">BEGIN</span> <span class="p">;</span>
<span class="k">DELETE</span> <span class="k">FROM</span> <span class="n">child_index</span> <span class="k">WHERE</span> <span class="n">parent_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">child_index</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'child_index_1'</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">COMMIT</span> <span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>When data does not exist, the second transaction acquires the lock immediately during delete.
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">BEGIN</span> <span class="p">;</span>
<span class="k">DELETE</span> <span class="k">FROM</span> <span class="n">child_index</span> <span class="k">WHERE</span> <span class="n">parent_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">child_index</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'child_index_1'</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">COMMIT</span> <span class="p">;</span>
</code></pre></div>    </div>
    <h4 id="query-based-on-non-indexed-column">Query Based on Non-Indexed Column</h4>
  </li>
  <li>Whether data exists or not, the second transaction waits for the lock during delete.
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">BEGIN</span> <span class="p">;</span>
<span class="k">DELETE</span> <span class="k">FROM</span> <span class="n">child_index</span> <span class="k">WHERE</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">'child_index_2'</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">child_index</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'child_index_1'</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">COMMIT</span> <span class="p">;</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="for-the-record">For the Record</h3>
<details>
<summary>SHOW ENGINE innodb STATUS;</summary>
  *** (1) TRANSACTION:TRANSACTION 13034, ACTIVE 6 sec insertingmysql tables in use 1, locked 1LOCK WAIT 4 lock struct(s), heap size 1128, 3 row lock(s), undo log entries 1MySQL thread id 280, OS thread handle 6136639488, query id 21716 localhost 127.0.0.1 root update/* ApplicationName=DataGrip 2022.3.2 */ insert into child values ('2', 'name2', 2)

*** (1) HOLDS THE LOCK(S):RECORD LOCKS space id 154 page no 4 n bits 72 index PRIMARY of table jpa.child trx id 13034 lock_mode X locks rec but not gapRecord lock, heap no 3 PHYSICAL RECORD: n_fields 5; compact format; info bits 0

*** (1) WAITING FOR THIS LOCK TO BE GRANTED:RECORD LOCKS space id 154 page no 5 n bits 72 index parent_id of table jpa.child trx id 13034 lock_mode X insert intention waitingRecord lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0

*** (2) TRANSACTION:TRANSACTION 13035, ACTIVE 4 sec insertingmysql tables in use 1, locked 1LOCK WAIT 3 lock struct(s), heap size 1128, 2 row lock(s)MySQL thread id 281, OS thread handle 6135525376, query id 21726 localhost 127.0.0.1 root update/* ApplicationName=DataGrip 2022.3.2 */ insert into child values ('2', 'name2', 2)

*** (2) HOLDS THE LOCK(S):RECORD LOCKS space id 154 page no 5 n bits 72 index parent_id of table jpa.child trx id 13035 lock_mode XRecord lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0

*** (2) WAITING FOR THIS LOCK TO BE GRANTED:RECORD LOCKS space id 154 page no 4 n bits 72 index PRIMARY of table jpa.child trx id 13035 lock mode S locks rec but not gap waitingRecord lock, heap no 3 PHYSICAL RECORD: n_fields 5; compact format; info bits 0

- SELECT * FROM performance_schema.data_locks;

| INDEX\_NAME | OBJECT\_INSTANCE\_BEGIN | LOCK\_TYPE | LOCK\_MODE | LOCK\_STATUS | LOCK\_DATA |
| :--- | :--- | :--- | :--- | :--- | :--- |
| null | 4813003272 | TABLE | IX | GRANTED | null |
| parent\_id | 4823656472 | RECORD | X | GRANTED | supremum pseudo-record |
| parent\_id | 4823656816 | RECORD | X,INSERT\_INTENTION | GRANTED | supremum pseudo-record |
| parent\_id | 4823657160 | RECORD | X,GAP | GRANTED | 1, 1 |
</details>]]></content><author><name>Hocaron</name><email>kkannu0407@gmail.com</email></author><category term="Troubleshooting" /><summary type="html"><![CDATA[Have I Defeated It? Pepe starts crying again… (Stop crying!) Let’s record this as a meaningful experience. Reproducing the Deadlock Scenario Current Table State CREATE TABLE parent ( id bigint not null primary key, name varchar(255) null, updated_at datetime(6) null ); CREATE TABLE child ( id bigint not null primary key, name varchar(255) null, parent_id bigint null, CONSTRAINT parent_id_unique UNIQUE (parent_id) ); CREATE TABLE child_index ( id bigint not null primary key, name varchar(255) null, parent_id bigint null ); CREATE INDEX parent_id ON child_index (parent_id); INSERT INTO parent VALUES (1, 'parent_1', NOW()); Created the child_index table with parent_id as an index (foreign key removed for testing). Created the child table with parent_id as a unique key (foreign key removed for testing). Inserted test data into the parent table. Let’s Cause a Deadlock Performing row delete on child_index followed by row insert on child_index in two sessions causes a deadlock 💣 TX1 TX2 Lock BEGIN ; DELETE FROM child_index WHERE parent_id = 2;   (1) Child X Lock, but TX2 can acquire X Lock 🤔   BEGIN ; DELETE FROM child_index WHERE parent_id = 2; (2) Child X Lock INSERT INTO child_index VALUES (‘1’, ‘name2’, 2);   (3) Waiting for Child X, INSERT_INTENTION Lock   INSERT INTO child_index VALUES (‘2’, ‘name2’, 2); (4) Waiting for Child X, INSERT_INTENTION Lock   Deadlock found when trying to get lock; try restarting transaction (4) Needs Child X lock, but (2) holds Child X lock To resolve (4), (3) must resolve To resolve (3), TX2 must commit To commit TX2, (4) must resolve -&gt; Deadlock occurs Examining the Deadlock Logic in Production Performing row delete on child_index followed by row insert on child_index in two sessions causes a deadlock 💣 SELECT * FROM parent WHERE id = 1; INSERT INTO child VALUES (1, 'child_1', 1); DELETE FROM child_index WHERE parent_id = 1; INSERT INTO child_index VALUES (1, 'child_index_1', 1); UPDATE parent SET updated_at = NOW() WHERE id = 1; @Transactional public void createChildAndChildIndex(long parentId) { var parent = parentRepository.findById(parentId); childIndexRepository.deleteByParent(parent); childIndexRepository.save(new Child_Index('child_index_1', parent)); } Interestingly, a deadlock occurs when the data to be deleted does not exist. When the data to be deleted exists, the lock waits until it can be acquired. Solutions to Resolve the Deadlock in Production ❎ First Attempt: Delete Row Only If It Exists @Transactional public void createParent(long parentId) { var parent = parentRepository.findById(parentId); if (childIndexRepository.findByParent(parent).isPresent()) { childIndexRepository.deleteByParent(parent); } childIndexRepository.save(new Child_Index('child_index_1', parent)); } This prevents the exclusive lock due to the unconditional delete logic. If concurrent requests find no data in childIndexRepository.findByParent, data may be duplicated. Testing with a 300ms thread sleep confirmed duplication. ✅ Second Attempt: Delete Row Only If It Exists with Unique Constraint CREATE TABLE child_index ( id bigint not null primary key, name varchar(255) null, parent_id bigint null, CONSTRAINT parent_id_unique UNIQUE (parent_id) ); CREATE INDEX parent_id ON child_index (parent_id); Concurrent requests with no data found in childIndexRepository.findByParent result in a duplicate key error for subsequent commits. ❎ Third Attempt: Add Key for Concurrency Control in Redis Due to occasional deadlocks and the absence of Redis usage in this service, the cache resource overhead seemed excessive. ❎ Fourth Attempt: Limit Requests Using Bucket4j to limit the number of API calls a client can make within a specific time frame. Deadlock prevention is impossible with multiple servers as concurrent requests can hit different servers. Summary When data is not present, delete queries allow delete and select but wait for the lock during insert. For more on locks, refer to the InnoDB Locking Documentation in MySQL Official Manual. It is well-organized with examples. Interesting Experiment Query Based on Indexed Column When data exists, the second transaction waits for the lock during delete. BEGIN ; DELETE FROM child_index WHERE parent_id = 1; INSERT INTO child_index VALUES (1, 'child_index_1', 1); COMMIT ; When data does not exist, the second transaction acquires the lock immediately during delete. BEGIN ; DELETE FROM child_index WHERE parent_id = 1; INSERT INTO child_index VALUES (1, 'child_index_1', 1); COMMIT ; Query Based on Non-Indexed Column Whether data exists or not, the second transaction waits for the lock during delete. BEGIN ; DELETE FROM child_index WHERE name = 'child_index_2'; INSERT INTO child_index VALUES (1, 'child_index_1', 1); COMMIT ; For the Record SHOW ENGINE innodb STATUS; *** (1) TRANSACTION:TRANSACTION 13034, ACTIVE 6 sec insertingmysql tables in use 1, locked 1LOCK WAIT 4 lock struct(s), heap size 1128, 3 row lock(s), undo log entries 1MySQL thread id 280, OS thread handle 6136639488, query id 21716 localhost 127.0.0.1 root update/* ApplicationName=DataGrip 2022.3.2 */ insert into child values ('2', 'name2', 2) *** (1) HOLDS THE LOCK(S):RECORD LOCKS space id 154 page no 4 n bits 72 index PRIMARY of table jpa.child trx id 13034 lock_mode X locks rec but not gapRecord lock, heap no 3 PHYSICAL RECORD: n_fields 5; compact format; info bits 0 *** (1) WAITING FOR THIS LOCK TO BE GRANTED:RECORD LOCKS space id 154 page no 5 n bits 72 index parent_id of table jpa.child trx id 13034 lock_mode X insert intention waitingRecord lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0 *** (2) TRANSACTION:TRANSACTION 13035, ACTIVE 4 sec insertingmysql tables in use 1, locked 1LOCK WAIT 3 lock struct(s), heap size 1128, 2 row lock(s)MySQL thread id 281, OS thread handle 6135525376, query id 21726 localhost 127.0.0.1 root update/* ApplicationName=DataGrip 2022.3.2 */ insert into child values ('2', 'name2', 2) *** (2) HOLDS THE LOCK(S):RECORD LOCKS space id 154 page no 5 n bits 72 index parent_id of table jpa.child trx id 13035 lock_mode XRecord lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0 *** (2) WAITING FOR THIS LOCK TO BE GRANTED:RECORD LOCKS space id 154 page no 4 n bits 72 index PRIMARY of table jpa.child trx id 13035 lock mode S locks rec but not gap waitingRecord lock, heap no 3 PHYSICAL RECORD: n_fields 5; compact format; info bits 0 - SELECT * FROM performance_schema.data_locks; | INDEX\_NAME | OBJECT\_INSTANCE\_BEGIN | LOCK\_TYPE | LOCK\_MODE | LOCK\_STATUS | LOCK\_DATA | | :--- | :--- | :--- | :--- | :--- | :--- | | null | 4813003272 | TABLE | IX | GRANTED | null | | parent\_id | 4823656472 | RECORD | X | GRANTED | supremum pseudo-record | | parent\_id | 4823656816 | RECORD | X,INSERT\_INTENTION | GRANTED | supremum pseudo-record | | parent\_id | 4823657160 | RECORD | X,GAP | GRANTED | 1, 1 |]]></summary></entry><entry xml:lang="en"><title type="html">[Troubleshooting - DB] Foreign Key, Deadlock, and Query Delay Execution</title><link href="https://hocaron.github.io/dead-lock-by-fk/" rel="alternate" type="text/html" title="[Troubleshooting - DB] Foreign Key, Deadlock, and Query Delay Execution" /><published>2023-05-22T00:00:00+00:00</published><updated>2023-05-22T00:00:00+00:00</updated><id>https://hocaron.github.io/dead-lock-by-fk-en</id><content type="html" xml:base="https://hocaron.github.io/dead-lock-by-fk/"><![CDATA[<h2 id="foreign-key-and-deadlock">Foreign Key and Deadlock</h2>
<p><strong>Deadlock</strong> occurs when two or more processes are each waiting for the other to release a resource, resulting in a situation where none of the processes can proceed.<br />
<img src="https://velog.velcdn.com/images/haron/post/33d1e1aa-b838-40e9-bbbd-af4480a0d5fe/image.png" alt="Deadlock diagram" /><br />
In this scenario, P1 waits for the resource held by P2, P2 waits for the resource held by P3, and so on, until the last process Pn waits for the resource held by P1, creating a circular wait and causing a deadlock.</p>

<p><strong>Foreign Key</strong> is a key used to link two tables together. The table containing the foreign key is called the child table, and the table referenced by the foreign key is called the parent table.</p>

<blockquote>
  <p>In “Real MySQL” chapter 3, it states:
“Foreign keys can cause deadlocks as they require checking for data in both the parent and child tables, propagating locks across multiple tables. Hence, they are rarely used in practice.”</p>
</blockquote>

<p><img src="https://velog.velcdn.com/images/haron/post/9cb67c04-19fc-4701-98c1-b6a45971eaa9/image.png" alt="Locks propagation" /><br />
Oh… Locks propagate across multiple tables?!!</p>

<h2 id="reproducing-deadlock-situations">Reproducing Deadlock Situations</h2>
<h3 id="preparation-steps">Preparation Steps</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">parent</span>
<span class="p">(</span>
    <span class="n">id</span>             <span class="nb">bigint</span>        <span class="k">not</span> <span class="k">null</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>
    <span class="n">name</span>           <span class="nb">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span>  <span class="k">null</span><span class="p">,</span>
    <span class="n">updated_at</span>     <span class="nb">datetime</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>   <span class="k">null</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">child</span>
<span class="p">(</span>
    <span class="n">id</span>           <span class="nb">bigint</span>          <span class="k">not</span> <span class="k">null</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>
    <span class="n">name</span>         <span class="nb">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span>    <span class="k">null</span><span class="p">,</span>
    <span class="n">parent_id</span>    <span class="nb">bigint</span>          <span class="k">null</span><span class="p">,</span>
    <span class="k">CONSTRAINT</span> <span class="n">parent_id_unique</span> <span class="k">UNIQUE</span> <span class="p">(</span><span class="n">parent_id</span><span class="p">),</span>
    <span class="k">CONSTRAINT</span> <span class="n">child_fk</span> <span class="k">FOREIGN</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">parent_id</span><span class="p">)</span> <span class="k">REFERENCES</span> <span class="n">parent</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">child_index</span>
<span class="p">(</span>
    <span class="n">id</span>           <span class="nb">bigint</span>          <span class="k">not</span> <span class="k">null</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>
    <span class="n">name</span>         <span class="nb">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span>    <span class="k">null</span><span class="p">,</span>
    <span class="n">parent_id</span>    <span class="nb">bigint</span>          <span class="k">null</span><span class="p">,</span>
    <span class="k">CONSTRAINT</span> <span class="n">child_index_fk</span> <span class="k">FOREIGN</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">parent_id</span><span class="p">)</span> <span class="k">REFERENCES</span> <span class="n">parent</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">);</span>
<span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">parent_id</span> <span class="k">ON</span> <span class="n">child_index</span> <span class="p">(</span><span class="n">parent_id</span><span class="p">);</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">parent</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'parent_1'</span><span class="p">,</span> <span class="n">NOW</span><span class="p">());</span>
</code></pre></div></div>
<ol>
  <li>Create the child table with a foreign key/unique key referencing the parent table’s id.</li>
  <li>Create the child_index table with a foreign key/index referencing the parent table’s id.</li>
  <li>Insert test data into the parent table.</li>
</ol>

<h3 id="now-lets-cause-a-deadlock">Now, Let’s Cause a Deadlock</h3>
<h3 id="if-a-child-row-insert-and-a-parent-row-update-are-performed-in-two-sessions-a-deadlock-occurs-">If a child row insert and a parent row update are performed in two sessions, a deadlock occurs 💣</h3>
<p><img src="https://velog.velcdn.com/images/haron/post/64f10100-a470-43a9-af95-c4a372b5bd22/image.png" alt="Deadlock situation" /></p>

<table>
  <thead>
    <tr>
      <th>TX1</th>
      <th>TX2</th>
      <th>lock</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>BEGIN ;  <br /> INSERT INTO child VALUES (1, ‘child1’, 1);</td>
      <td> </td>
      <td>(1) child X, REC_NOT_GAP Lock, parent S Lock</td>
    </tr>
    <tr>
      <td> </td>
      <td>BEGIN ;  <br /> INSERT INTO child VALUES (1, ‘child1’, 1);</td>
      <td>(2) child X Lock waiting, parent S Lock</td>
    </tr>
    <tr>
      <td>UPDATE parent SET name = ‘newParent’ WHERE id = 1;</td>
      <td> </td>
      <td>(3)</td>
    </tr>
    <tr>
      <td> </td>
      <td>Deadlock found when trying to get lock; try restarting transaction</td>
      <td>(3) parent X lock required, but parent is in S lock in (2) <br /> To resolve (3), (2) needs to be resolved <br /> -&gt; To resolve (2), TX1 commit is required <br /> -&gt; To commit TX1, (3) needs to be resolved <br /> -&gt; Deadlock occurs</td>
    </tr>
  </tbody>
</table>

<p><img src="https://velog.velcdn.com/images/haron/post/609d3b4c-6e3d-4743-af14-5449b7b730fe/image.jpeg" alt="Deadlock explanation" /></p>

<blockquote>
  <p>When performing a write query on the child table, the foreign key constraint causes the parent’s lock state to be checked. If there’s no issue, the query is executed, and to maintain consistency, a shared lock is placed on the corresponding row in the parent table.</p>
</blockquote>

<blockquote>
  <p><strong>Shared Lock (S Lock)</strong><br />
A shared lock, also known as a read lock, allows read operations (SELECT) on the locked data but prohibits write operations. Other transactions can acquire a shared lock on the same data, but cannot acquire an exclusive lock. This ensures that the data cannot be modified while it’s being read, maintaining transaction integrity.</p>
</blockquote>

<blockquote>
  <p><strong>Exclusive Lock (X Lock)</strong><br />
An exclusive lock, also known as a write lock, allows both read and write operations for the transaction that holds the lock. Other transactions cannot perform any operations (read or write) on the locked data. This guarantees exclusive access to the locked data for the transaction holding the lock.</p>
</blockquote>

<h3 id="if-a-parent-row-update-and-a-child-row-insert-are-performed-in-two-sessions-a-duplicate-key-error-occurs-instead-of-a-deadlock">If a parent row update and a child row insert are performed in two sessions, a duplicate key error occurs instead of a deadlock</h3>
<p><img src="https://velog.velcdn.com/images/haron/post/f36e285b-25f9-42f7-a233-7864a0ad9244/image.png" alt="Duplicate key error" /><br />
If the parent row is updated first, a deadlock does not occur. The duplicate key error is an expected behavior due to service-specific requirements.</p>

<h2 id="analyzing-the-logic-causing-deadlock-in-production">Analyzing the Logic Causing Deadlock in Production</h2>
<ul>
  <li>The service uses JPA, so let’s check with the <code class="language-plaintext highlighter-rouge">show-sql</code> option.
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">from</span> <span class="n">parent</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">child</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'child_1'</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">DELETE</span> <span class="k">FROM</span> <span class="n">child_index</span> <span class="k">WHERE</span> <span class="n">parent_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">child_index</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'child_index_1'</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">UPDATE</span> <span class="n">parent</span> <span class="k">SET</span>  <span class="n">updated_at</span> <span class="o">=</span> <span class="n">NOW</span><span class="p">()</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div>    </div>
    <p>(Tables and columns are simplified versions)</p>
  </li>
</ul>

<h3 id="if-a-child-row-insert-and-a-parent-row-update-are-performed-in-two-sessions-a-deadlock-occurs--1">If a child row insert and a parent row update are performed in two sessions, a deadlock occurs 💣</h3>
<p><img src="https://velog.velcdn.com/images/haron/post/b5700769-98a0-45f6-9858-2594d362f922/image.png" alt="Deadlock diagram" /></p>

<ul>
  <li>The reason for execution in two sessions is due to multiple simultaneous requests from the front end 🖱🤏🖱🤏.</li>
  <li>It’s curious that this issue only occurs with this specific button, while other buttons do not cause deadlocks 🤔.</li>
</ul>

<h2 id="understanding-the-cause-and-exploring-solutions-to-deadlock">Understanding the Cause and Exploring Solutions to Deadlock</h2>

<h3 id="-first-attempt-adjust-logic-to-perform-parent-row-update-before-child-row-insert-to-cause-a-duplicate-key-error">❎ First Attempt: Adjust Logic to Perform Parent Row Update Before Child Row Insert to Cause a Duplicate Key Error</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@Transactional</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createChildAndChildIndex</span> <span class="o">(</span><span class="kt">long</span> <span class="n">parentId</span><span class="o">)</span> <span class="o">{</span>

    <span class="kt">var</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">parentRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">parentId</span><span class="o">);</span>
    <span class="c1">// Update parent row</span>
    <span class="n">parent</span><span class="o">.</span><span class="na">setUpdatedAt</span><span class="o">(</span><span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">());</span>
    
    <span class="c1">// Insert child row</span>
    <span class="n">childRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="k">new</span> <span class="nc">Child</span><span class="o">(</span><span class="err">'</span><span class="n">child_1</span><span class="err">'</span><span class="o">,</span> <span class="n">parent</span><span class="o">));</span>
    
    <span class="n">childIndexRepository</span><span class="o">.</span><span class="na">deleteByParent</span><span class="o">(</span><span class="n">parent</span><span class="o">);</span>
    <span class="n">childIndexRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="k">new</span> <span class="n">Child_Index</span><span class="o">(</span><span class="err">'</span><span class="n">child_index_1</span><span class="err">'</span><span class="o">,</span> <span class="n">parent</span><span class="o">));</span>

  <span class="o">}</span>
</code></pre></div></div>
<p>However, queries are still executed in the order: child row insert → parent row update, causing deadlocks. 😇</p>

<h3 id="hibernate-query-execution-order">Hibernate Query Execution Order</h3>
<p>Although it is known that JPA’s write-behind strategy defers query execution until the transaction commits, there is an order of execution.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>OrphanRemovalAction
AbstractEntityInsertAction
EntityUpdateAction
QueuedOperationCollectionAction
CollectionRemoveAction
CollectionUpdateAction
CollectionRecreateAction
EntityDeleteAction

1. Inserts, in the order they were performed
2. Updates
3. Deletion of collection elements
4. Insertion of collection elements
5. Deletes, in the order they were performed
</code></pre></div></div>
<p>FYI: <a href="https://docs.jboss.org/hibernate/orm/6.1/javadocs/org/hibernate/event/internal/AbstractFlushingEventListener.html#performExecutions(org.hibernate.event.spi.EventSource)">Hibernate Query Execution Order</a></p>

<blockquote>
  <p><strong>What is a Foreign Key Constraint?</strong>
When inserting data into a table with a foreign key, the referenced table must contain the actual data being referenced. This ensures data integrity by preventing references to non-existent data. This is likely why inserts are executed first!</p>
</blockquote>

<p>The reason the logic still results in a child row insert before a parent row update is due to the write-behind strategy, where inserts are prioritized over updates.</p>

<h3 id="-second-attempt-use-flush-after-parent-row-update-to-ensure-query-execution-order">❎ Second Attempt: Use <code class="language-plaintext highlighter-rouge">flush()</code> After Parent Row Update to Ensure Query Execution Order</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@Transactional</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createParent</span> <span class="o">(</span><span class="kt">long</span> <span class="n">parentId</span><span class="o">)</span> <span class="o">{</span>

    <span class="kt">var</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">parentRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">parentId</span><span class="o">);</span>
    <span class="c1">// Update parent row</span>
    <span class="n">parent</span><span class="o">.</span><span class="na">setUpdatedAt</span><span class="o">(</span><span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">());</span>
    <span class="c1">// Flush after parent row update</span>
    <span class="n">parentRepository</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
    
    <span class="c1">// Insert child row</span>
    <span class="n">childRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="k">new</span> <span class="nc">Child</span><span class="o">(</span><span class="err">'</span><span class="n">child_1</span><span class="err">'</span><span class="o">,</span> <span class="n">parent</span><span class="o">));</span>
    
    <span class="n">childIndexRepository</span><span class="o">.</span><span class="na">deleteByParent</span><span class="o">(</span><span class="n">parent</span><span class="o">);</span>
    <span class="n">childIndexRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="k">new</span> <span class="n">Child_Index</span><span class="o">(</span><span class="err">'</span><span class="n">child_index_1</span><span class="err">'</span><span class="o">,</span> <span class="n">parent</span><span class="o">));</span>

  <span class="o">}</span>
</code></pre></div></div>

<p>Queries are executed as intended!</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">from</span> <span class="n">parent</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">UPDATE</span> <span class="n">parent</span> <span class="k">SET</span>  <span class="n">updated_at</span> <span class="o">=</span> <span class="n">NOW</span><span class="p">()</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">child</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'child_1'</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">DELETE</span> <span class="k">FROM</span> <span class="n">child_index</span> <span class="k">WHERE</span> <span class="n">parent_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">child_index</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'child_index_1'</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li>However, there are concerns about potential side effects of <code class="language-plaintext highlighter-rouge">flush()</code> and confusion for future developers seeing an unexpected <code class="language-plaintext highlighter-rouge">flush()</code> call.</li>
</ul>

<h3 id="-third-attempt-remove-foreign-key-from-the-child-table">✅ Third Attempt: Remove Foreign Key from the Child Table</h3>
<p>🤔 How long does it take to remove a foreign key from a table with 2,288,112 rows?!</p>

<ul>
  <li>The deadlock occurs because a change in a child row also causes a shared lock on the parent row. Removing the root cause might solve the problem.</li>
  <li>Concerned about potential service downtime during foreign key removal, we tested it. On a table with 54,973 rows, it took only 14 ms.</li>
</ul>

<p><img src="https://velog.velcdn.com/images/haron/post/b66d04a1-8e93-4f24-a8bb-f135946f7669/image.png" alt="Foreign key removal time" /></p>
<ul>
  <li>After discussing within the team, we removed the foreign key without service interruption. Monitoring showed that after removing the foreign key, <code class="language-plaintext highlighter-rouge">SQLTransactionRollbackException</code> (deadlock) was replaced by <code class="language-plaintext highlighter-rouge">DataIntegrityViolationException</code> (duplicate key).</li>
</ul>

<p><img src="https://velog.velcdn.com/images/haron/post/fa8c8a3e-ad61-4977-b1ff-585b0d262293/image.png" alt="Post foreign key removal" /></p>

<h3 id="not-defeated-yet">Not Defeated Yet…</h3>
<p><a href="https://velog.io/@haron/%ED%8A%B8%EB%9F%AC%EB%B8%94%EC%8A%88%ED%8C%85-DB-%EC%9D%B8%EB%8D%B1%EC%8A%A4Index%EC%99%80-%EB%8D%B0%EB%93%9C%EB%9D%BDDeadLock-in8ryzsm">The Index Was Waiting for Me…</a></p>

<h2 id="summary">Summary</h2>
<ol>
  <li>When a foreign key is present, a change in a child row causes a shared lock on the parent row.</li>
  <li>There is an execution order for JPA’s write-behind strategy.</li>
  <li>The time taken to remove an FK key is shorter than expected.</li>
</ol>

<h3 id="for-the-record">For the Record</h3>
<details>
<summary>SHOW ENGINE innodb STATUS;</summary>
- SHOW ENGINE innodb STATUS;
  LOCK WAIT 4 lock struct(s), heap size 1128, 2 row lock(s), undo log entries 1
  *** (1) HOLDS THE LOCK(S):

RECORD LOCKS space id 148 page no 4 n bits 72 index PRIMARY of table `jpa`.`parent` trx id 12534 lock mode S locks rec but not gap

Record lock, heap no 2 PHYSICAL RECORD: n_fields 4; compact format; info bits 0

*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 149 page no 5 n bits 72 index parent_id_unique of table `jpa`.`child` trx id 12534 lock mode S waiting
Record lock, heap no 2 PHYSICAL RECORD: n_fields 2; compact format; info bits 0

*** (2) TRANSACTION:

TRANSACTION 12533, ACTIVE 13 sec starting index read

mysql tables in use 1, locked 1

LOCK WAIT 6 lock struct(s), heap size 1128, 3 row lock(s), undo log entries 1

MySQL thread id 128, OS thread handle 6143324160, query id 12894 localhost 127.0.0.1 root updating

/* ApplicationName=DataGrip 2022.3.2 */ UPDATE parent SET name = 'newParent' WHERE id = 1

*** (2) HOLDS THE LOCK(S):
RECORD LOCKS space id 149 page no 5 n bits 72 index parent_id_unique of table `jpa`.`child` trx id 12533 lock_mode X locks rec but not gap
Record lock, heap no 2 PHYSICAL RECORD: n_fields 2; compact format; info bits 0

*** (2) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 148 page no 4 n bits 72 index PRIMARY of table `jpa`.`parent` trx id 12533 lock_mode X locks rec but not gap waiting

Record lock, heap no 2 PHYSICAL RECORD: n_fields 4; compact format; info bits 0
</details>]]></content><author><name>Hocaron</name><email>kkannu0407@gmail.com</email></author><category term="Troubleshooting" /><summary type="html"><![CDATA[Foreign Key and Deadlock Deadlock occurs when two or more processes are each waiting for the other to release a resource, resulting in a situation where none of the processes can proceed. In this scenario, P1 waits for the resource held by P2, P2 waits for the resource held by P3, and so on, until the last process Pn waits for the resource held by P1, creating a circular wait and causing a deadlock. Foreign Key is a key used to link two tables together. The table containing the foreign key is called the child table, and the table referenced by the foreign key is called the parent table. In “Real MySQL” chapter 3, it states: “Foreign keys can cause deadlocks as they require checking for data in both the parent and child tables, propagating locks across multiple tables. Hence, they are rarely used in practice.” Oh… Locks propagate across multiple tables?!! Reproducing Deadlock Situations Preparation Steps CREATE TABLE parent ( id bigint not null primary key, name varchar(255) null, updated_at datetime(6) null ); CREATE TABLE child ( id bigint not null primary key, name varchar(255) null, parent_id bigint null, CONSTRAINT parent_id_unique UNIQUE (parent_id), CONSTRAINT child_fk FOREIGN KEY (parent_id) REFERENCES parent (id) ); CREATE TABLE child_index ( id bigint not null primary key, name varchar(255) null, parent_id bigint null, CONSTRAINT child_index_fk FOREIGN KEY (parent_id) REFERENCES parent (id) ); CREATE INDEX parent_id ON child_index (parent_id); INSERT INTO parent VALUES (1, 'parent_1', NOW()); Create the child table with a foreign key/unique key referencing the parent table’s id. Create the child_index table with a foreign key/index referencing the parent table’s id. Insert test data into the parent table. Now, Let’s Cause a Deadlock If a child row insert and a parent row update are performed in two sessions, a deadlock occurs 💣 TX1 TX2 lock BEGIN ; INSERT INTO child VALUES (1, ‘child1’, 1);   (1) child X, REC_NOT_GAP Lock, parent S Lock   BEGIN ; INSERT INTO child VALUES (1, ‘child1’, 1); (2) child X Lock waiting, parent S Lock UPDATE parent SET name = ‘newParent’ WHERE id = 1;   (3)   Deadlock found when trying to get lock; try restarting transaction (3) parent X lock required, but parent is in S lock in (2) To resolve (3), (2) needs to be resolved -&gt; To resolve (2), TX1 commit is required -&gt; To commit TX1, (3) needs to be resolved -&gt; Deadlock occurs When performing a write query on the child table, the foreign key constraint causes the parent’s lock state to be checked. If there’s no issue, the query is executed, and to maintain consistency, a shared lock is placed on the corresponding row in the parent table. Shared Lock (S Lock) A shared lock, also known as a read lock, allows read operations (SELECT) on the locked data but prohibits write operations. Other transactions can acquire a shared lock on the same data, but cannot acquire an exclusive lock. This ensures that the data cannot be modified while it’s being read, maintaining transaction integrity. Exclusive Lock (X Lock) An exclusive lock, also known as a write lock, allows both read and write operations for the transaction that holds the lock. Other transactions cannot perform any operations (read or write) on the locked data. This guarantees exclusive access to the locked data for the transaction holding the lock. If a parent row update and a child row insert are performed in two sessions, a duplicate key error occurs instead of a deadlock If the parent row is updated first, a deadlock does not occur. The duplicate key error is an expected behavior due to service-specific requirements. Analyzing the Logic Causing Deadlock in Production The service uses JPA, so let’s check with the show-sql option. SELECT * from parent WHERE id = 1; INSERT INTO child VALUES (1, 'child_1', 1); DELETE FROM child_index WHERE parent_id = 1; INSERT INTO child_index VALUES (1, 'child_index_1', 1); UPDATE parent SET updated_at = NOW() WHERE id = 1; (Tables and columns are simplified versions) If a child row insert and a parent row update are performed in two sessions, a deadlock occurs 💣 The reason for execution in two sessions is due to multiple simultaneous requests from the front end 🖱🤏🖱🤏. It’s curious that this issue only occurs with this specific button, while other buttons do not cause deadlocks 🤔. Understanding the Cause and Exploring Solutions to Deadlock ❎ First Attempt: Adjust Logic to Perform Parent Row Update Before Child Row Insert to Cause a Duplicate Key Error @Transactional public void createChildAndChildIndex (long parentId) { var parent = parentRepository.findById(parentId); // Update parent row parent.setUpdatedAt(LocalDateTime.now()); // Insert child row childRepository.save(new Child('child_1', parent)); childIndexRepository.deleteByParent(parent); childIndexRepository.save(new Child_Index('child_index_1', parent)); } However, queries are still executed in the order: child row insert → parent row update, causing deadlocks. 😇 Hibernate Query Execution Order Although it is known that JPA’s write-behind strategy defers query execution until the transaction commits, there is an order of execution. OrphanRemovalAction AbstractEntityInsertAction EntityUpdateAction QueuedOperationCollectionAction CollectionRemoveAction CollectionUpdateAction CollectionRecreateAction EntityDeleteAction 1. Inserts, in the order they were performed 2. Updates 3. Deletion of collection elements 4. Insertion of collection elements 5. Deletes, in the order they were performed FYI: Hibernate Query Execution Order What is a Foreign Key Constraint? When inserting data into a table with a foreign key, the referenced table must contain the actual data being referenced. This ensures data integrity by preventing references to non-existent data. This is likely why inserts are executed first! The reason the logic still results in a child row insert before a parent row update is due to the write-behind strategy, where inserts are prioritized over updates. ❎ Second Attempt: Use flush() After Parent Row Update to Ensure Query Execution Order @Transactional public void createParent (long parentId) { var parent = parentRepository.findById(parentId); // Update parent row parent.setUpdatedAt(LocalDateTime.now()); // Flush after parent row update parentRepository.flush(); // Insert child row childRepository.save(new Child('child_1', parent)); childIndexRepository.deleteByParent(parent); childIndexRepository.save(new Child_Index('child_index_1', parent)); } Queries are executed as intended! SELECT * from parent WHERE id = 1; UPDATE parent SET updated_at = NOW() WHERE id = 1; INSERT INTO child VALUES (1, 'child_1', 1); DELETE FROM child_index WHERE parent_id = 1; INSERT INTO child_index VALUES (1, 'child_index_1', 1); However, there are concerns about potential side effects of flush() and confusion for future developers seeing an unexpected flush() call. ✅ Third Attempt: Remove Foreign Key from the Child Table 🤔 How long does it take to remove a foreign key from a table with 2,288,112 rows?! The deadlock occurs because a change in a child row also causes a shared lock on the parent row. Removing the root cause might solve the problem. Concerned about potential service downtime during foreign key removal, we tested it. On a table with 54,973 rows, it took only 14 ms. After discussing within the team, we removed the foreign key without service interruption. Monitoring showed that after removing the foreign key, SQLTransactionRollbackException (deadlock) was replaced by DataIntegrityViolationException (duplicate key). Not Defeated Yet… The Index Was Waiting for Me… Summary When a foreign key is present, a change in a child row causes a shared lock on the parent row. There is an execution order for JPA’s write-behind strategy. The time taken to remove an FK key is shorter than expected. For the Record SHOW ENGINE innodb STATUS; - SHOW ENGINE innodb STATUS; LOCK WAIT 4 lock struct(s), heap size 1128, 2 row lock(s), undo log entries 1 *** (1) HOLDS THE LOCK(S): RECORD LOCKS space id 148 page no 4 n bits 72 index PRIMARY of table `jpa`.`parent` trx id 12534 lock mode S locks rec but not gap Record lock, heap no 2 PHYSICAL RECORD: n_fields 4; compact format; info bits 0 *** (1) WAITING FOR THIS LOCK TO BE GRANTED: RECORD LOCKS space id 149 page no 5 n bits 72 index parent_id_unique of table `jpa`.`child` trx id 12534 lock mode S waiting Record lock, heap no 2 PHYSICAL RECORD: n_fields 2; compact format; info bits 0 *** (2) TRANSACTION: TRANSACTION 12533, ACTIVE 13 sec starting index read mysql tables in use 1, locked 1 LOCK WAIT 6 lock struct(s), heap size 1128, 3 row lock(s), undo log entries 1 MySQL thread id 128, OS thread handle 6143324160, query id 12894 localhost 127.0.0.1 root updating /* ApplicationName=DataGrip 2022.3.2 */ UPDATE parent SET name = 'newParent' WHERE id = 1 *** (2) HOLDS THE LOCK(S): RECORD LOCKS space id 149 page no 5 n bits 72 index parent_id_unique of table `jpa`.`child` trx id 12533 lock_mode X locks rec but not gap Record lock, heap no 2 PHYSICAL RECORD: n_fields 2; compact format; info bits 0 *** (2) WAITING FOR THIS LOCK TO BE GRANTED: RECORD LOCKS space id 148 page no 4 n bits 72 index PRIMARY of table `jpa`.`parent` trx id 12533 lock_mode X locks rec but not gap waiting Record lock, heap no 2 PHYSICAL RECORD: n_fields 4; compact format; info bits 0]]></summary></entry></feed>