<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Home | public var hocaron</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="Home" />
<meta name="author" content="Hocaron" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Minimal Jekyll theme for storytellers" />
<meta property="og:description" content="Minimal Jekyll theme for storytellers" />
<link rel="canonical" href="https://hocaron.github.io/" />
<meta property="og:url" content="https://hocaron.github.io/" />
<meta property="og:site_name" content="public var hocaron" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Home" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebSite","author":{"@type":"Person","name":"Hocaron","url":"https://hocaron.github.io"},"description":"Minimal Jekyll theme for storytellers","headline":"Home","name":"public var hocaron","url":"https://hocaron.github.io/"}</script>
<!-- End Jekyll SEO tag -->


  <!-- CSS -->
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="stylesheet" href="../assets/main.js">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.1/css/all.min.css" />

  <!-- Favicon -->
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png">

  <!-- RSS -->
  <link type="application/atom+xml" rel="alternate" href="https://hocaron.github.io/feed.xml" title="public var hocaron" />

  <!-- Google Analytics-->
  
  <script>
  window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
  ga('create', 'UA‚ÄîXXXXXXXX-X', 'auto');
  ga('send', 'pageview');
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  

  <!-- JavaScript -->
  <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
  <script type="text/javascript" src="../assets/main.js"></script>

  <!-- SEO for Polyglot -->
  
</head>


<body>
<div>
  




<nav class="nav">
  <div class="nav-container">
    <a href="/">
      <h2 class="nav-title">public var hocaron</h2>
    </a>
    <ul>
      <li class="selected">
      <a href="/">Posts</a>
      </li>
      <li >
        <a href="/series">Series</a>
      </li>
      <li >
        <a href="/about">About</a>
      </li>

      <li>
        
        
        
        <a class="lang "
           href="
                /ko/
              ">
          KOR
          |
        </a>
        
        
        
        <a class="lang active"
           href="
                /
              ">
          ENG
          
        </a>
        
      </li>

    </ul>
  </div>
</nav>


  <main>
    <div class="catalogue">
  
    
  
    
  

  
    <a href="/dead-lock-by-index/" class="catalogue-item">
  <div>
    
    <time datetime="2023-05-23 00:00:00 +0000" class="catalogue-time">May 23, 2023</time>
    <h1 class="catalogue-title">[Troubleshooting - DB] Index and Deadlock</h1>
    <div class="catalogue-line"></div>

    <p>
      
        Have I Defeated It?

Pepe starts crying again‚Ä¶ (Stop crying!)

Let‚Äôs record this as a meaningful experience.



Reproducing the Deadlock Scenario

Current Table State
CREATE TABLE parent
(
    id             bigint        not null primary key,
    name           varchar(255)  null,
    updated_at     datetime(6)   null
);

CREATE TABLE child
(
    id           bigint          not null primary key,
    name         varchar(255)    null,
    parent_id    bigint          null,
    CONSTRAINT parent_id_unique UNIQUE (parent_id)
);

CREATE TABLE child_index
(
    id           bigint          not null primary key,
    name         varchar(255)    null,
    parent_id    bigint          null
);
CREATE INDEX parent_id ON child_index (parent_id);

INSERT INTO parent VALUES (1, 'parent_1', NOW());


  Created the child_index table with parent_id as an index (foreign key removed for testing).
  Created the child table with parent_id as a unique key (foreign key removed for testing).
  Inserted test data into the parent table.


Let‚Äôs Cause a Deadlock

Performing row delete on child_index followed by row insert on child_index in two sessions causes a deadlock üí£




  
    
      TX1
      TX2
      Lock
    
  
  
    
      BEGIN ; DELETE FROM child_index WHERE parent_id = 2;
      ¬†
      (1) Child X Lock, but TX2 can acquire X Lock ü§î
    
    
      ¬†
      BEGIN ; DELETE FROM child_index WHERE parent_id = 2;
      (2) Child X Lock
    
    
      INSERT INTO child_index VALUES (‚Äò1‚Äô, ‚Äòname2‚Äô, 2);
      ¬†
      (3) Waiting for Child X, INSERT_INTENTION Lock
    
    
      ¬†
      INSERT INTO child_index VALUES (‚Äò2‚Äô, ‚Äòname2‚Äô, 2);
      (4) Waiting for Child X, INSERT_INTENTION Lock
    
    
      ¬†
      Deadlock found when trying to get lock; try restarting transaction
      (4) Needs Child X lock, but (2) holds Child X lock  To resolve (4), (3) must resolve  To resolve (3), TX2 must commit  To commit TX2, (4) must resolve  -&gt; Deadlock occurs
    
  


Examining the Deadlock Logic in Production

Performing row delete on child_index followed by row insert on child_index in two sessions causes a deadlock üí£

SELECT * FROM parent WHERE id = 1;
INSERT INTO child VALUES (1, 'child_1', 1);
DELETE FROM child_index WHERE parent_id = 1;
INSERT INTO child_index VALUES (1, 'child_index_1', 1);
UPDATE parent SET updated_at = NOW() WHERE id = 1;


@Transactional
public void createChildAndChildIndex(long parentId) {
    var parent = parentRepository.findById(parentId);

    childIndexRepository.deleteByParent(parent);
    childIndexRepository.save(new Child_Index('child_index_1', parent));
}


  Interestingly, a deadlock occurs when the data to be deleted does not exist.
  When the data to be deleted exists, the lock waits until it can be acquired.


Solutions to Resolve the Deadlock in Production

‚ùé First Attempt: Delete Row Only If It Exists
@Transactional
public void createParent(long parentId) {
    var parent = parentRepository.findById(parentId);

    if (childIndexRepository.findByParent(parent).isPresent()) {
        childIndexRepository.deleteByParent(parent);
    }
    childIndexRepository.save(new Child_Index('child_index_1', parent));
}


  This prevents the exclusive lock due to the unconditional delete logic.
  If concurrent requests find no data in childIndexRepository.findByParent, data may be duplicated.
    
      Testing with a 300ms thread sleep confirmed duplication.
    
  


‚úÖ Second Attempt: Delete Row Only If It Exists with Unique Constraint
CREATE TABLE child_index
(
    id           bigint          not null primary key,
    name         varchar(255)    null,
    parent_id    bigint          null,
    CONSTRAINT parent_id_unique UNIQUE (parent_id)
);
CREATE INDEX parent_id ON child_index (parent_id);


  Concurrent requests with no data found in childIndexRepository.findByParent result in a duplicate key error for subsequent commits.


‚ùé Third Attempt: Add Key for Concurrency Control in Redis

  Due to occasional deadlocks and the absence of Redis usage in this service, the cache resource overhead seemed excessive.


‚ùé Fourth Attempt: Limit Requests

  Using Bucket4j to limit the number of API calls a client can make within a specific time frame.
  Deadlock prevention is impossible with multiple servers as concurrent requests can hit different servers.


Summary

  When data is not present, delete queries allow delete and select but wait for the lock during insert.
  For more on locks, refer to the InnoDB Locking Documentation in MySQL Official Manual. It is well-organized with examples.


Interesting Experiment
Query Based on Indexed Column

  When data exists, the second transaction waits for the lock during delete.
    BEGIN ;
DELETE FROM child_index WHERE parent_id = 1;
INSERT INTO child_index VALUES (1, 'child_index_1', 1);
COMMIT ;
    
  
  When data does not exist, the second transaction acquires the lock immediately during delete.
    BEGIN ;
DELETE FROM child_index WHERE parent_id = 1;
INSERT INTO child_index VALUES (1, 'child_index_1', 1);
COMMIT ;
    
    Query Based on Non-Indexed Column
  
  Whether data exists or not, the second transaction waits for the lock during delete.
    BEGIN ;
DELETE FROM child_index WHERE name = 'child_index_2';
INSERT INTO child_index VALUES (1, 'child_index_1', 1);
COMMIT ;
    
  


For the Record

SHOW ENGINE innodb STATUS;
  *** (1) TRANSACTION:TRANSACTION 13034, ACTIVE 6 sec insertingmysql tables in use 1, locked 1LOCK WAIT 4 lock struct(s), heap size 1128, 3 row lock(s), undo log entries 1MySQL thread id 280, OS thread handle 6136639488, query id 21716 localhost 127.0.0.1 root update/* ApplicationName=DataGrip 2022.3.2 */ insert into child values ('2', 'name2', 2)

*** (1) HOLDS THE LOCK(S):RECORD LOCKS space id 154 page no 4 n bits 72 index PRIMARY of table jpa.child trx id 13034 lock_mode X locks rec but not gapRecord lock, heap no 3 PHYSICAL RECORD: n_fields 5; compact format; info bits 0

*** (1) WAITING FOR THIS LOCK TO BE GRANTED:RECORD LOCKS space id 154 page no 5 n bits 72 index parent_id of table jpa.child trx id 13034 lock_mode X insert intention waitingRecord lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0

*** (2) TRANSACTION:TRANSACTION 13035, ACTIVE 4 sec insertingmysql tables in use 1, locked 1LOCK WAIT 3 lock struct(s), heap size 1128, 2 row lock(s)MySQL thread id 281, OS thread handle 6135525376, query id 21726 localhost 127.0.0.1 root update/* ApplicationName=DataGrip 2022.3.2 */ insert into child values ('2', 'name2', 2)

*** (2) HOLDS THE LOCK(S):RECORD LOCKS space id 154 page no 5 n bits 72 index parent_id of table jpa.child trx id 13035 lock_mode XRecord lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0

*** (2) WAITING FOR THIS LOCK TO BE GRANTED:RECORD LOCKS space id 154 page no 4 n bits 72 index PRIMARY of table jpa.child trx id 13035 lock mode S locks rec but not gap waitingRecord lock, heap no 3 PHYSICAL RECORD: n_fields 5; compact format; info bits 0

- SELECT * FROM performance_schema.data_locks;

| INDEX\_NAME | OBJECT\_INSTANCE\_BEGIN | LOCK\_TYPE | LOCK\_MODE | LOCK\_STATUS | LOCK\_DATA |
| :--- | :--- | :--- | :--- | :--- | :--- |
| null | 4813003272 | TABLE | IX | GRANTED | null |
| parent\_id | 4823656472 | RECORD | X | GRANTED | supremum pseudo-record |
| parent\_id | 4823656816 | RECORD | X,INSERT\_INTENTION | GRANTED | supremum pseudo-record |
| parent\_id | 4823657160 | RECORD | X,GAP | GRANTED | 1, 1 |


      
    </p>

  </div>
</a>

  
    <a href="/dead-lock-by-fk/" class="catalogue-item">
  <div>
    
    <time datetime="2023-05-22 00:00:00 +0000" class="catalogue-time">May 22, 2023</time>
    <h1 class="catalogue-title">[Troubleshooting - DB] Foreign Key, Deadlock, and Query Delay Execution</h1>
    <div class="catalogue-line"></div>

    <p>
      
        Foreign Key and Deadlock
Deadlock occurs when two or more processes are each waiting for the other to release a resource, resulting in a situation where none of the processes can proceed.

In this scenario, P1 waits for the resource held by P2, P2 waits for the resource held by P3, and so on, until the last process Pn waits for the resource held by P1, creating a circular wait and causing a deadlock.

Foreign Key is a key used to link two tables together. The table containing the foreign key is called the child table, and the table referenced by the foreign key is called the parent table.


  In ‚ÄúReal MySQL‚Äù chapter 3, it states:
‚ÄúForeign keys can cause deadlocks as they require checking for data in both the parent and child tables, propagating locks across multiple tables. Hence, they are rarely used in practice.‚Äù



Oh‚Ä¶ Locks propagate across multiple tables?!!

Reproducing Deadlock Situations
Preparation Steps

CREATE TABLE parent
(
    id             bigint        not null primary key,
    name           varchar(255)  null,
    updated_at     datetime(6)   null
);

CREATE TABLE child
(
    id           bigint          not null primary key,
    name         varchar(255)    null,
    parent_id    bigint          null,
    CONSTRAINT parent_id_unique UNIQUE (parent_id),
    CONSTRAINT child_fk FOREIGN KEY (parent_id) REFERENCES parent (id)
);

CREATE TABLE child_index
(
    id           bigint          not null primary key,
    name         varchar(255)    null,
    parent_id    bigint          null,
    CONSTRAINT child_index_fk FOREIGN KEY (parent_id) REFERENCES parent (id)
);
CREATE INDEX parent_id ON child_index (parent_id);

INSERT INTO parent VALUES (1, 'parent_1', NOW());


  Create the child table with a foreign key/unique key referencing the parent table‚Äôs id.
  Create the child_index table with a foreign key/index referencing the parent table‚Äôs id.
  Insert test data into the parent table.


Now, Let‚Äôs Cause a Deadlock
If a child row insert and a parent row update are performed in two sessions, a deadlock occurs üí£



  
    
      TX1
      TX2
      lock
    
  
  
    
      BEGIN ;   INSERT INTO child VALUES (1, ‚Äòchild1‚Äô, 1);
      ¬†
      (1) child X, REC_NOT_GAP Lock, parent S Lock
    
    
      ¬†
      BEGIN ;   INSERT INTO child VALUES (1, ‚Äòchild1‚Äô, 1);
      (2) child X Lock waiting, parent S Lock
    
    
      UPDATE parent SET name = ‚ÄònewParent‚Äô WHERE id = 1;
      ¬†
      (3)
    
    
      ¬†
      Deadlock found when trying to get lock; try restarting transaction
      (3) parent X lock required, but parent is in S lock in (2)  To resolve (3), (2) needs to be resolved  -&gt; To resolve (2), TX1 commit is required  -&gt; To commit TX1, (3) needs to be resolved  -&gt; Deadlock occurs
    
  





  When performing a write query on the child table, the foreign key constraint causes the parent‚Äôs lock state to be checked. If there‚Äôs no issue, the query is executed, and to maintain consistency, a shared lock is placed on the corresponding row in the parent table.



  Shared Lock (S Lock)
A shared lock, also known as a read lock, allows read operations (SELECT) on the locked data but prohibits write operations. Other transactions can acquire a shared lock on the same data, but cannot acquire an exclusive lock. This ensures that the data cannot be modified while it‚Äôs being read, maintaining transaction integrity.



  Exclusive Lock (X Lock)
An exclusive lock, also known as a write lock, allows both read and write operations for the transaction that holds the lock. Other transactions cannot perform any operations (read or write) on the locked data. This guarantees exclusive access to the locked data for the transaction holding the lock.


If a parent row update and a child row insert are performed in two sessions, a duplicate key error occurs instead of a deadlock

If the parent row is updated first, a deadlock does not occur. The duplicate key error is an expected behavior due to service-specific requirements.

Analyzing the Logic Causing Deadlock in Production

  The service uses JPA, so let‚Äôs check with the show-sql option.
    SELECT * from parent WHERE id = 1;
INSERT INTO child VALUES (1, 'child_1', 1);
DELETE FROM child_index WHERE parent_id = 1;
INSERT INTO child_index VALUES (1, 'child_index_1', 1);
UPDATE parent SET  updated_at = NOW() WHERE id = 1;
    
    (Tables and columns are simplified versions)
  


If a child row insert and a parent row update are performed in two sessions, a deadlock occurs üí£



  The reason for execution in two sessions is due to multiple simultaneous requests from the front end üñ±ü§èüñ±ü§è.
  It‚Äôs curious that this issue only occurs with this specific button, while other buttons do not cause deadlocks ü§î.


Understanding the Cause and Exploring Solutions to Deadlock

‚ùé First Attempt: Adjust Logic to Perform Parent Row Update Before Child Row Insert to Cause a Duplicate Key Error
  @Transactional
  public void createChildAndChildIndex (long parentId) {

    var parent = parentRepository.findById(parentId);
    // Update parent row
    parent.setUpdatedAt(LocalDateTime.now());
    
    // Insert child row
    childRepository.save(new Child('child_1', parent));
    
    childIndexRepository.deleteByParent(parent);
    childIndexRepository.save(new Child_Index('child_index_1', parent));

  }

However, queries are still executed in the order: child row insert ‚Üí parent row update, causing deadlocks. üòá

Hibernate Query Execution Order
Although it is known that JPA‚Äôs write-behind strategy defers query execution until the transaction commits, there is an order of execution.

OrphanRemovalAction
AbstractEntityInsertAction
EntityUpdateAction
QueuedOperationCollectionAction
CollectionRemoveAction
CollectionUpdateAction
CollectionRecreateAction
EntityDeleteAction

1. Inserts, in the order they were performed
2. Updates
3. Deletion of collection elements
4. Insertion of collection elements
5. Deletes, in the order they were performed

FYI: Hibernate Query Execution Order


  What is a Foreign Key Constraint?
When inserting data into a table with a foreign key, the referenced table must contain the actual data being referenced. This ensures data integrity by preventing references to non-existent data. This is likely why inserts are executed first!


The reason the logic still results in a child row insert before a parent row update is due to the write-behind strategy, where inserts are prioritized over updates.

‚ùé Second Attempt: Use flush() After Parent Row Update to Ensure Query Execution Order
  @Transactional
  public void createParent (long parentId) {

    var parent = parentRepository.findById(parentId);
    // Update parent row
    parent.setUpdatedAt(LocalDateTime.now());
    // Flush after parent row update
    parentRepository.flush();
    
    // Insert child row
    childRepository.save(new Child('child_1', parent));
    
    childIndexRepository.deleteByParent(parent);
    childIndexRepository.save(new Child_Index('child_index_1', parent));

  }


Queries are executed as intended!
SELECT * from parent WHERE id = 1;
UPDATE parent SET  updated_at = NOW() WHERE id = 1;
INSERT INTO child VALUES (1, 'child_1', 1);
DELETE FROM child_index WHERE parent_id = 1;
INSERT INTO child_index VALUES (1, 'child_index_1', 1);


  However, there are concerns about potential side effects of flush() and confusion for future developers seeing an unexpected flush() call.


‚úÖ Third Attempt: Remove Foreign Key from the Child Table
ü§î How long does it take to remove a foreign key from a table with 2,288,112 rows?!


  The deadlock occurs because a change in a child row also causes a shared lock on the parent row. Removing the root cause might solve the problem.
  Concerned about potential service downtime during foreign key removal, we tested it. On a table with 54,973 rows, it took only 14 ms.




  After discussing within the team, we removed the foreign key without service interruption. Monitoring showed that after removing the foreign key, SQLTransactionRollbackException (deadlock) was replaced by DataIntegrityViolationException (duplicate key).




Not Defeated Yet‚Ä¶
The Index Was Waiting for Me‚Ä¶

Summary

  When a foreign key is present, a change in a child row causes a shared lock on the parent row.
  There is an execution order for JPA‚Äôs write-behind strategy.
  The time taken to remove an FK key is shorter than expected.


For the Record

SHOW ENGINE innodb STATUS;
- SHOW ENGINE innodb STATUS;
  LOCK WAIT 4 lock struct(s), heap size 1128, 2 row lock(s), undo log entries 1
  *** (1) HOLDS THE LOCK(S):

RECORD LOCKS space id 148 page no 4 n bits 72 index PRIMARY of table `jpa`.`parent` trx id 12534 lock mode S locks rec but not gap

Record lock, heap no 2 PHYSICAL RECORD: n_fields 4; compact format; info bits 0

*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 149 page no 5 n bits 72 index parent_id_unique of table `jpa`.`child` trx id 12534 lock mode S waiting
Record lock, heap no 2 PHYSICAL RECORD: n_fields 2; compact format; info bits 0

*** (2) TRANSACTION:

TRANSACTION 12533, ACTIVE 13 sec starting index read

mysql tables in use 1, locked 1

LOCK WAIT 6 lock struct(s), heap size 1128, 3 row lock(s), undo log entries 1

MySQL thread id 128, OS thread handle 6143324160, query id 12894 localhost 127.0.0.1 root updating

/* ApplicationName=DataGrip 2022.3.2 */ UPDATE parent SET name = 'newParent' WHERE id = 1

*** (2) HOLDS THE LOCK(S):
RECORD LOCKS space id 149 page no 5 n bits 72 index parent_id_unique of table `jpa`.`child` trx id 12533 lock_mode X locks rec but not gap
Record lock, heap no 2 PHYSICAL RECORD: n_fields 2; compact format; info bits 0

*** (2) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 148 page no 4 n bits 72 index PRIMARY of table `jpa`.`parent` trx id 12533 lock_mode X locks rec but not gap waiting

Record lock, heap no 2 PHYSICAL RECORD: n_fields 4; compact format; info bits 0


      
    </p>

  </div>
</a>

  
</div>

<div class="pagination">
  
  

  <span>1</span>
</div>

  </main>

  <footer>
  <a href="mailto:kkannu0407@gmail.com">
    <i class="far fa-envelope fa-fw"></i>
  </a>
  <a href="https://github.com/hocaron" target="_blank">
    <i class="fab fa-github fa-fw"></i>
  </a>
  <a href="https://www.linkedin.com/in/sunwoo-ho-86b45823a" target="_blank">
    <i class="fab fa-linkedin fa-fw"></i>
  </a>

  <br>
  <span>&copy; 2024 Hocaron</span>
</footer>

</div>
</body>
</html>
